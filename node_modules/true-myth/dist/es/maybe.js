/** [[include:doc/maybe.md]] */
/** (keep typedoc from getting confused by the imports) */
import { err, ok } from './result';
import { curry1, isVoid } from './utils';
/**
  Discriminant for the `Just` and `Nothing` variants.

  You can use the discriminant via the `variant` property of `Maybe` instances
  if you need to match explicitly on it.
 */
export var Variant;
(function (Variant) {
    Variant["Just"] = "Just";
    Variant["Nothing"] = "Nothing";
})(Variant || (Variant = {}));
/**
  A `Just` instance is the *present* variant instance of the
  [`Maybe`](../modules/_maybe_.html#maybe) type, representing the presence of a
  value which may be absent. For a full discussion, see [the module
  docs](../modules/_maybe_.html).

  @typeparam T The type wrapped in this `Just` variant of `Maybe`.
 */
export class Just {
    /**
      Create an instance of `Maybe.Just` with `new`.
  
      @note While you *may* create the `Just` type via normal JavaScript
      class construction, it is not recommended for the functional style for
      which the library is intended. Instead, use [`Maybe.of`] (for the general
      case) or [`Maybe.just`] for this specific case.
  
      [`Maybe.of`]: ../modules/_maybe_.html#of
      [`Maybe.just`]: ../modules/_maybe_.html#just
  
      ```ts
      // Avoid:
      const aString = new Maybe.Just('characters');
  
      // Prefer:
      const aString = Maybe.just('characters);
      ```
  
      @param value
      The value to wrap in a `Maybe.Just`.
  
      `null` and `undefined` are allowed by the type signature so that the
      constructor may `throw` on those rather than constructing a type like
      `Maybe<undefined>`.
  
      @throws      If you pass `null` or `undefined`.
     */
    constructor(value) {
        /** `Just` is always [`Variant.Just`](../enums/_maybe_.variant#just). */
        this.variant = Variant.Just;
        if (isVoid(value)) {
            throw new Error('Tried to construct `Just` with `null` or `undefined`');
        }
        this.value = value;
    }
    /**
      Unwrap the contained value. A convenience method for functional idioms.
  
      A common scenario where you might want to use this is in a pipeline of
      functions:
  
      ```ts
      import Maybe, { Just } from 'true-myth/maybe';
  
      function getLengths(maybeStrings: Array<Maybe<string>>): Array<number> {
        return maybeStrings
          .filter(Maybe.isJust)
          .map(Just.unwrap)
          .map(s => s.length);
      }
      ```
     */
    static unwrap(theJust) {
        return theJust.value;
    }
    /** Method variant for [`Maybe.isJust`](../modules/_maybe_.html#isjust) */
    isJust() {
        return true;
    }
    /** Method variant for [`Maybe.isNothing`](../modules/_maybe_.html#isnothing) */
    isNothing() {
        return false;
    }
    /** Method variant for [`Maybe.map`](../modules/_maybe_.html#map) */
    map(mapFn) {
        return map(mapFn, this);
    }
    /** Method variant for [`Maybe.mapOr`](../modules/_maybe_.html#mapor) */
    mapOr(orU, mapFn) {
        return mapOr(orU, mapFn, this);
    }
    /** Method variant for [`Maybe.mapOrElse`](../modules/_maybe_.html#maporelse) */
    mapOrElse(orElseFn, mapFn) {
        return mapOrElse(orElseFn, mapFn, this);
    }
    /** Method variant for [`Maybe.match`](../modules/_maybe_.html#match) */
    match(matcher) {
        return match(matcher, this);
    }
    /** Method variant for [`Maybe.or`](../modules/_maybe_.html#or) */
    or(mOr) {
        return or(mOr, this);
    }
    /** Method variant for [`Maybe.orElse`](../modules/_maybe_.html#orelse) */
    orElse(orElseFn) {
        return orElse(orElseFn, this);
    }
    /** Method variant for [`Maybe.and`](../modules/_maybe_.html#and) */
    and(mAnd) {
        return and(mAnd, this);
    }
    /** Method variant for [`Maybe.andThen`](../modules/_maybe_.html#andthen) */
    andThen(andThenFn) {
        return andThen(andThenFn, this);
    }
    /** Method variant for [`Maybe.chain`](../modules/_maybe_.html#chain) */
    chain(chainFn) {
        return this.andThen(chainFn);
    }
    /** Method variant for [`Maybe.flatMap`](../modules/_maybe_.html#flatmap) */
    flatMap(flatMapFn) {
        return this.andThen(flatMapFn);
    }
    /** Method variant for [`Maybe.unsafelyUnwrap`](../modules/_maybe_.html#unsafelyunwrap) */
    unsafelyUnwrap() {
        return this.value;
    }
    /** Method variant for [`Maybe.unwrapOr`](../modules/_maybe_.html#unwrapor) */
    unwrapOr(defaultValue) {
        return unwrapOr(defaultValue, this);
    }
    /** Method variant for [`Maybe.unwrapOrElse`](../modules/_maybe_.html#unwraporelse) */
    unwrapOrElse(elseFn) {
        return unwrapOrElse(elseFn, this);
    }
    /** Method variant for [`Maybe.toOkOrErr`](../modules/_maybe_.html#tookorerr) */
    toOkOrErr(error) {
        return toOkOrErr(error, this);
    }
    /** Method variant for [`Maybe.toOkOrElseErr`](../modules/_maybe_.html#tookorelseerr) */
    toOkOrElseErr(elseFn) {
        return toOkOrElseErr(elseFn, this);
    }
    /** Method variant for [`Maybe.toString`](../modules/_maybe_.html#tostring) */
    toString() {
        return toString(this);
    }
    /** Method variant for [`Maybe.equals`](../modules/_maybe_.html#equals) */
    equals(comparison) {
        return equals(comparison, this);
    }
    /** Method variant for [`Maybe.ap`](../modules/_maybe_.html#ap) */
    ap(val) {
        return ap(this, val);
    }
    /**
      Method variant for [`Maybe.get`](../modules/_maybe_.html#prop)
  
          If you have a `Maybe` of an object type, you can do `thatMaybe.get('a key')`
      to look up the next layer down in the object.
  
      ```ts
      type DeepOptionalType = {
        something?: {
          with?: {
            deeperKeys?: string;
          }
        }
      };
  
      const fullySet: DeepType = {
        something: {
          with: {
            deeperKeys: 'like this'
          }
        }
      };
  
      const deepJust = Maybe.of(fullySet)
        .get('something')
        .get('with')
        .get('deeperKeys');
  
      console.log(deepJust); // Just('like this');
  
      const partiallyUnset: DeepType = { something: { } };
  
      const deepEmpty = Maybe.of(partiallyUnset)
        .get('something')
        .get('with')
        .get('deeperKeys');
  
      console.log(deepEmpty); // Nothing
      ```
     */
    get(key) {
        return this.andThen(property(key));
    }
}
/**
  A `Nothing` instance is the *absent* variant instance of the
  [`Maybe`](../modules/_maybe_.html#maybe) type, representing the presence of a
  value which may be absent. For a full discussion, see [the module
  docs](../modules/_maybe_.html).

  @typeparam T The type which would be wrapped in a `Just` variant of `Maybe`.
 */
export class Nothing {
    /**
      Create an instance of `Maybe.Nothing` with `new`.
  
      @note While you *may* create the `Nothing` type via normal JavaScript
      class construction, it is not recommended for the functional style for
      which the library is intended. Instead, use [`Maybe.of`] (for the general
      case) or [`Maybe.nothing`] for this specific case.
  
      [`Maybe.of`]: ../modules/_maybe_.html#of
      [`Maybe.nothing`]: ../modules/_maybe_.html#nothing
  
      ```ts
      // Avoid:
      const aNothing = new Maybe.Err();
  
      // Prefer:
      const aNothing = Maybe.nothing();
      ```
  
      `null` and `undefined` are allowed so that you may explicitly construct the
      `Err` type with a known `null` or `undefined` value. (This maybe helpful
      primarily when transitioning a codebase to the use of `Maybe`.)
  
      @throws      If you pass `null` or `undefined`.
     */
    constructor(_) {
        /** `Nothing` is always [`Variant.Nothing`](../enums/_maybe_.variant#nothing). */
        this.variant = Variant.Nothing;
        /* nothing to do */
    }
    /** Method variant for [`Maybe.isJust`](../modules/_maybe_.html#isjust) */
    isJust() {
        return false;
    }
    /** Method variant for [`Maybe.isNothing`](../modules/_maybe_.html#isnothing) */
    isNothing() {
        return true;
    }
    /** Method variant for [`Maybe.map`](../modules/_maybe_.html#map) */
    map(mapFn) {
        return map(mapFn, this);
    }
    /** Method variant for [`Maybe.mapOr`](../modules/_maybe_.html#mapor) */
    mapOr(orU, mapFn) {
        return mapOr(orU, mapFn, this);
    }
    /** Method variant for [`Maybe.mapOrElse`](../modules/_maybe_.html#maporelse) */
    mapOrElse(orElseFn, mapFn) {
        return mapOrElse(orElseFn, mapFn, this);
    }
    /** Method variant for [`Maybe.match`](../modules/_maybe_.html#match) */
    match(matcher) {
        return match(matcher, this);
    }
    /** Method variant for [`Maybe.or`](../modules/_maybe_.html#or) */
    or(mOr) {
        return or(mOr, this);
    }
    /** Method variant for [`Maybe.orElse`](../modules/_maybe_.html#orelse) */
    orElse(orElseFn) {
        return orElse(orElseFn, this);
    }
    /** Method variant for [`Maybe.and`](../modules/_maybe_.html#and) */
    and(mAnd) {
        return and(mAnd, this);
    }
    /** Method variant for [`Maybe.andThen`](../modules/_maybe_.html#andthen) */
    andThen(andThenFn) {
        return andThen(andThenFn, this);
    }
    /** Method variant for [`Maybe.chain`](../modules/_maybe_.html#chain) */
    chain(chainFn) {
        return this.andThen(chainFn);
    }
    /** Method variant for [`Maybe.flatMap`](../modules/_maybe_.html#flatmap) */
    flatMap(flatMapFn) {
        return this.andThen(flatMapFn);
    }
    /** Method variant for [`Maybe.unsafelyUnwrap`](../modules/_maybe_.html#unsafelyunwrap) */
    unsafelyUnwrap() {
        throw new Error('Tried to `unsafelyUnwrap(Nothing)`');
    }
    /** Method variant for [`Maybe.unwrapOr`](../modules/_maybe_.html#unwrapor) */
    unwrapOr(defaultValue) {
        return unwrapOr(defaultValue, this);
    }
    /** Method variant for [`Maybe.unwrapOrElse`](../modules/_maybe_.html#unwraporelse) */
    unwrapOrElse(elseFn) {
        return unwrapOrElse(elseFn, this);
    }
    /** Method variant for [`Maybe.toOkOrErr`](../modules/_maybe_.html#tookorerr) */
    toOkOrErr(error) {
        return toOkOrErr(error, this);
    }
    /** Method variant for [`Maybe.toOkOrElseErr`](../modules/_maybe_.html#tookorelseerr) */
    toOkOrElseErr(elseFn) {
        return toOkOrElseErr(elseFn, this);
    }
    /** Method variant for [`Maybe.toString`](../modules/_maybe_.html#tostring) */
    toString() {
        return toString(this);
    }
    /** Method variant for [`Maybe.equals`](../modules/_maybe_.html#equals) */
    equals(comparison) {
        return equals(comparison, this);
    }
    /** Method variant for [`Maybe.ap`](../modules/_maybe_.html#ap) */
    ap(val) {
        return ap(this, val);
    }
    /**
      Method variant for [`Maybe.get`](../modules/_maybe_.html#prop)
  
          If you have a `Maybe` of an object type, you can do `thatMaybe.get('a key')`
      to look up the next layer down in the object.
  
      ```ts
      type DeepOptionalType = {
        something?: {
          with?: {
            deeperKeys?: string;
          }
        }
      };
  
      const fullySet: DeepType = {
        something: {
          with: {
            deeperKeys: 'like this'
          }
        }
      };
  
      const deepJust = Maybe.of(fullySet)
        .get('something')
        .get('with')
        .get('deeperKeys');
  
      console.log(deepJust); // Just('like this');
  
      const partiallyUnset: DeepType = { something: { } };
  
      const deepEmpty = Maybe.of(partiallyUnset)
        .get('something')
        .get('with')
        .get('deeperKeys');
  
      console.log(deepEmpty); // Nothing
      ```
     */
    get(key) {
        return this.andThen(property(key));
    }
}
/**
  Is this result a `Just` instance?

  @typeparam T The type of the wrapped value.
  @param maybe The `Maybe` instance to check.
  @returns     `true` if `maybe` is `Just`, `false` otherwise. In TypeScript,
               also narrows the type from `Maybe<T>` to `Just<T>`.
 */
export function isJust(maybe) {
    return maybe.variant === Variant.Just;
}
/**
  Is this result a `Nothing` instance?

  @typeparam T The type of the wrapped value.
  @param maybe The `Maybe` instance to check.
  @returns     `true` if `maybe` is `nothing`, `false` otherwise. In TypeScript,
               also narrows the type from `Maybe<T>` to `Nothing<T>`.
 */
export function isNothing(maybe) {
    return maybe.variant === Variant.Nothing;
}
/**
  Create an instance of `Maybe.Just`.

  `null` and `undefined` are allowed by the type signature so that the
  function may `throw` on those rather than constructing a type like
  `Maybe<undefined>`.

  @typeparam T The type of the item contained in the `Maybe`.
  @param value The value to wrap in a `Maybe.Just`.
  @returns     An instance of `Maybe.Just<T>`.
  @throws      If you pass `null` or `undefined`.
 */
export function just(value) {
    return new Just(value);
}
/**
  Create an instance of `Maybe.Nothing`.

  If you want to create an instance with a specific type, e.g. for use in a
  function which expects a `Maybe<T>` where the `<T>` is known but you have no
  value to give it, you can use a type parameter:

  ```ts
  const notString = Maybe.nothing<string>();
  ```

  @typeparam T The type of the item contained in the `Maybe`.
  @returns     An instance of `Maybe.Nothing<T>`.
 */
export function nothing(_) {
    return new Nothing(_);
}
/**
  Create a `Maybe` from any value.

  To specify that the result should be interpreted as a specific type, you may
  invoke `Maybe.of` with an explicit type parameter:

  ```ts
  const foo = Maybe.of<string>(null);
  ```

  This is usually only important in two cases:

  1.  If you are intentionally constructing a `Nothing` from a known `null` or
      undefined value *which is untyped*.
  2.  If you are specifying that the type is more general than the value passed
      (since TypeScript can define types as literals).

  @typeparam T The type of the item contained in the `Maybe`.
  @param value The value to wrap in a `Maybe`. If it is `undefined` or `null`,
               the result will be `Nothing`; otherwise it will be the type of
               the value passed.
 */
export function of(value) {
    return isVoid(value) ? nothing() : just(value);
}
/** Alias for [`of`](#of), primarily for compatibility with Folktale. */
export const fromNullable = of;
export function map(mapFn, maybe) {
    const op = (m) => (m.isJust() ? just(mapFn(m.value)) : nothing());
    return curry1(op, maybe);
}
export function mapOr(orU, mapFn, maybe) {
    function fullOp(fn, m) {
        return m.isJust() ? fn(m.value) : orU;
    }
    function partialOp(fn, curriedMaybe) {
        return curriedMaybe !== undefined
            ? fullOp(fn, curriedMaybe)
            : (extraCurriedMaybe) => fullOp(fn, extraCurriedMaybe);
    }
    return mapFn === undefined
        ? partialOp
        : maybe === undefined
            ? partialOp(mapFn)
            : partialOp(mapFn, maybe);
}
export function mapOrElse(orElseFn, mapFn, maybe) {
    function fullOp(fn, m) {
        return m.isJust() ? fn(m.value) : orElseFn();
    }
    function partialOp(fn, curriedMaybe) {
        return curriedMaybe !== undefined
            ? fullOp(fn, curriedMaybe)
            : (extraCurriedMaybe) => fullOp(fn, extraCurriedMaybe);
    }
    if (mapFn === undefined) {
        return partialOp;
    }
    else if (maybe === undefined) {
        return partialOp(mapFn);
    }
    else {
        return partialOp(mapFn, maybe);
    }
}
export function and(andMaybe, maybe) {
    const op = (m) => (m.isJust() ? andMaybe : nothing());
    return curry1(op, maybe);
}
export function andThen(thenFn, maybe) {
    const op = (m) => (m.isJust() ? thenFn(m.value) : nothing());
    return maybe !== undefined ? op(maybe) : op;
}
/** Alias for [`andThen`](#andthen). */
export const chain = andThen;
/** Alias for [`andThen`](#andthen). */
export const flatMap = andThen;
export function or(defaultMaybe, maybe) {
    const op = (m) => (m.isJust() ? m : defaultMaybe);
    return maybe !== undefined ? op(maybe) : op;
}
export function orElse(elseFn, maybe) {
    const op = (m) => (m.isJust() ? m : elseFn());
    return curry1(op, maybe);
}
/**
  Get the value out of the `Maybe`.

  Returns the content of a `Just`, but **throws if the `Maybe` is `Nothing`**.
  Prefer to use [`unwrapOr`](#unwrapor) or [`unwrapOrElse`](#unwraporelse).

  @typeparam T The type of the wrapped value.
  @param maybe The value to unwrap
  @returns     The unwrapped value if the `Maybe` instance is `Just`.
  @throws      If the `maybe` is `Nothing`.
 */
export function unsafelyUnwrap(maybe) {
    return maybe.unsafelyUnwrap();
}
/** Alias for [`unsafelyUnwrap`](#unsafelyunwrap) */
export const unsafelyGet = unsafelyUnwrap;
/** Alias for [`unsafelyUnwrap`](#unsafelyunwrap) */
export const unsafeGet = unsafelyUnwrap;
export function unwrapOr(defaultValue, maybe) {
    const op = (m) => (m.isJust() ? m.value : defaultValue);
    return curry1(op, maybe);
}
/** Alias for [`unwrapOr`](#unwrapor) */
export const getOr = unwrapOr;
export function unwrapOrElse(orElseFn, maybe) {
    const op = (m) => (m.isJust() ? m.value : orElseFn());
    return curry1(op, maybe);
}
/** Alias for [`unwrapOrElse`](#unwraporelse) */
export const getOrElse = unwrapOrElse;
export function toOkOrErr(error, maybe) {
    const op = (m) => (m.isJust() ? ok(m.value) : err(error));
    return maybe !== undefined ? op(maybe) : op;
}
export function toOkOrElseErr(elseFn, maybe) {
    const op = (m) => (m.isJust() ? ok(m.value) : err(elseFn()));
    return curry1(op, maybe);
}
/**
  Construct a `Maybe<T>` from a `Result<T, E>`.

  If the `Result` is an `Ok`, wrap its value in `Just`. If the `Result` is an
  `Err`, throw away the wrapped `E` and transform to a `Nothing`.

  @typeparam T  The type of the value wrapped in a `Result.Ok` and in the `Just`
                of the resulting `Maybe`.
  @typeparam E  The type of the value wrapped in a `Result.Err`; thrown away in
                the resulting `Maybe`.
  @param result The `Result` to construct a `Maybe` from.
  @returns      `Just` if `result` was `Ok` or `Nothing` if it was `Err`.
 */
export function fromResult(result) {
    return result.isOk() ? just(result.value) : nothing();
}
/**
  Create a `String` representation of a `Maybe` instance.

  A `Just` instance will be printed as `Just(<representation of the value>)`,
  where the representation of the value is simply the value's own `toString`
  representation. For example:

  | call                                   | output                  |
  |----------------------------------------|-------------------------|
  | `toString(Maybe.of(42))`               | `Just(42)`              |
  | `toString(Maybe.of([1, 2, 3]))`        | `Just(1,2,3)`           |
  | `toString(Maybe.of({ an: 'object' }))` | `Just([object Object])` |
  | `toString(Maybe.nothing())`            | `Nothing`               |

  @typeparam T The type of the wrapped value; its own `.toString` will be used
               to print the interior contents of the `Just` variant.
  @param maybe The value to convert to a string.
  @returns     The string representation of the `Maybe`.
 */
export function toString(maybe) {
    const body = maybe.isJust() ? `(${maybe.value.toString()})` : '';
    return `${maybe.variant}${body}`;
}
export function match(matcher, maybe) {
    return maybe !== undefined
        ? mapOrElse(matcher.Nothing, matcher.Just, maybe)
        : (curriedMaybe) => mapOrElse(matcher.Nothing, matcher.Just, curriedMaybe);
}
/** Alias for [`match`](#match) */
export const cata = match;
export function equals(mb, ma) {
    return ma !== undefined
        ? ma.match({
            Just: aVal => mb.isJust() && mb.unsafelyUnwrap() === aVal,
            Nothing: () => isNothing(mb),
        })
        : (maybeA) => maybeA.match({
            Nothing: () => isNothing(mb),
            Just: aVal => mb.isJust() && mb.unsafelyUnwrap() === aVal,
        });
}
export function ap(maybeFn, maybe) {
    const op = (m) => m.match({
        Just: val => maybeFn.map(fn => fn(val)),
        Nothing: () => Maybe.nothing(),
    });
    return curry1(op, maybe);
}
/**
  Determine whether an item is an instance of `Just` or `Nothing`.

  @param item The item to check.
 */
export function isInstance(item) {
    return item instanceof Just || item instanceof Nothing;
}
export function find(predicate, array) {
    const op = (a) => Maybe.of(a.find(predicate));
    return curry1(op, array);
}
/**
  Safely get the first item from a list, returning `Just` the first item if the
  array has at least one item in it, or `Nothing` if it is empty.

  ## Examples

  ```ts
  let empty = [];
  Maybe.head(empty); // => Nothing

  let full = [1, 2, 3];
  Maybe.head(full); // => Just(1)
  ```

  @param array The array to get the first item from.
 */
export function head(array) {
    return Maybe.of(array[0]);
}
/** A convenience alias for `Maybe.head`. */
export const first = head;
/**
  Safely get the last item from a list, returning `Just` the last item if the
  array has at least one item in it, or `Nothing` if it is empty.

  ## Examples

  ```ts
  let empty = [];
  Maybe.last(empty); // => Nothing

  let full = [1, 2, 3];
  Maybe.last(full); // => Just(3)
  ```

  @param array The array to get the first item from.
 */
export function last(array) {
    return Maybe.of(array[array.length - 1]);
}
/**
  Convert the arguments to a single `Maybe`. Useful for dealing with arrays of
  `Maybe`s, via the spread operator.

  ## Examples

  ```ts
  import Maybe from 'true-myth/maybe';

  let valid = [Maybe.just(2), Maybe.just('three')];
  Maybe.all(...valid); // => Just([2, 'three']);

  let invalid = [Maybe.just(2), Maybe.nothing<string>()];
  Maybe.all(...invalid); // => Nothing
  ```

  ## Note on Spread

  This requires the use of the spread operator because (at least as of
  TypeScript 3.0), the type inference falls down when attempting to build this
  same type with an array directly. Moreover, this spread-based approach handles
  heteregenous arrays; TS *also* fails to infer correctly for anything but
  homogeneous arrays when using that approach.

  @param maybes The `Maybe`s to resolve to a single `Maybe`.
 */
export function all(...maybes) {
    let result = Maybe.just([]);
    maybes.forEach(maybe => {
        result = result.andThen(accumulatedMaybes => maybe.map(m => {
            accumulatedMaybes.push(m);
            return accumulatedMaybes;
        }));
    });
    return result;
}
export function tuple(maybes) {
    // @ts-ignore -- this doesn't type-check, but it works correctly.
    return all(...maybes);
}
export function property(key, obj) {
    const op = (a) => Maybe.of(a[key]);
    return curry1(op, obj);
}
export function get(key, maybeObj) {
    return curry1(Maybe.andThen(property(key)), maybeObj);
}
export const Maybe = {
    Variant,
    Just,
    Nothing,
    all,
    isJust,
    isNothing,
    just,
    nothing,
    of,
    find,
    first,
    fromNullable,
    head,
    last,
    map,
    mapOr,
    mapOrElse,
    and,
    andThen,
    chain,
    flatMap,
    or,
    orElse,
    unsafelyUnwrap,
    unsafelyGet,
    unsafeGet,
    unwrapOr,
    getOr,
    unwrapOrElse,
    getOrElse,
    toOkOrErr,
    toOkOrElseErr,
    fromResult,
    toString,
    tuple,
    match,
    cata,
    equals,
    ap,
    isInstance,
    property,
    get,
};
export default Maybe;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF5YmUuanMiLCJzb3VyY2VSb290IjoiLi8iLCJzb3VyY2VzIjpbIm1heWJlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLCtCQUErQjtBQUUvQiwwREFBMEQ7QUFDMUQsT0FBZSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFDM0MsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFFekM7Ozs7O0dBS0c7QUFDSCxNQUFNLENBQU4sSUFBWSxPQUdYO0FBSEQsV0FBWSxPQUFPO0lBQ2pCLHdCQUFhLENBQUE7SUFDYiw4QkFBbUIsQ0FBQTtBQUNyQixDQUFDLEVBSFcsT0FBTyxLQUFQLE9BQU8sUUFHbEI7QUEyR0Q7Ozs7Ozs7R0FPRztBQUNILE1BQU0sT0FBTyxJQUFJO0lBNEJmOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0EyQkc7SUFDSCxZQUFZLEtBQWdCO1FBbEM1Qix3RUFBd0U7UUFDL0QsWUFBTyxHQUFpQixPQUFPLENBQUMsSUFBSSxDQUFDO1FBa0M1QyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNqQixNQUFNLElBQUksS0FBSyxDQUFDLHNEQUFzRCxDQUFDLENBQUM7U0FDekU7UUFFRCxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztJQUNyQixDQUFDO0lBN0REOzs7Ozs7Ozs7Ozs7Ozs7O09BZ0JHO0lBQ0gsTUFBTSxDQUFDLE1BQU0sQ0FBSSxPQUFnQjtRQUMvQixPQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUM7SUFDdkIsQ0FBQztJQTRDRCwwRUFBMEU7SUFDMUUsTUFBTTtRQUNKLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELGdGQUFnRjtJQUNoRixTQUFTO1FBQ1AsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQsb0VBQW9FO0lBQ3BFLEdBQUcsQ0FBb0IsS0FBa0I7UUFDdkMsT0FBTyxHQUFHLENBQUMsS0FBSyxFQUFFLElBQUks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QVM7SUFDVCxhQUFhO0lBQ2IsVUFBVTtJQUNWLFFBQVE7SUFDUixLQUFLO0lBQ0wsS0FBSztJQUNMLElBQUk7SUFDSixNQUFNO0lBQ04sRUFBRTtJQUNGLFVBQVU7SUFDVixRQUFRO0lBQ1IsR0FBRztDQUNKLENBQUM7QUFFRixlQUFlLEtBQUssQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBbW2luY2x1ZGU6ZG9jL21heWJlLm1kXV0gKi9cblxuLyoqIChrZWVwIHR5cGVkb2MgZnJvbSBnZXR0aW5nIGNvbmZ1c2VkIGJ5IHRoZSBpbXBvcnRzKSAqL1xuaW1wb3J0IFJlc3VsdCwgeyBlcnIsIG9rIH0gZnJvbSAnLi9yZXN1bHQnO1xuaW1wb3J0IHsgY3VycnkxLCBpc1ZvaWQgfSBmcm9tICcuL3V0aWxzJztcblxuLyoqXG4gIERpc2NyaW1pbmFudCBmb3IgdGhlIGBKdXN0YCBhbmQgYE5vdGhpbmdgIHZhcmlhbnRzLlxuXG4gIFlvdSBjYW4gdXNlIHRoZSBkaXNjcmltaW5hbnQgdmlhIHRoZSBgdmFyaWFudGAgcHJvcGVydHkgb2YgYE1heWJlYCBpbnN0YW5jZXNcbiAgaWYgeW91IG5lZWQgdG8gbWF0Y2ggZXhwbGljaXRseSBvbiBpdC5cbiAqL1xuZXhwb3J0IGVudW0gVmFyaWFudCB7XG4gIEp1c3QgPSAnSnVzdCcsXG4gIE5vdGhpbmcgPSAnTm90aGluZycsXG59XG5cbi8qKiBTaW1wbHkgZGVmaW5lcyB0aGUgY29tbW9uIHNoYXBlIGZvciBgSnVzdGAgYW5kIGBOb3RoaW5nYC4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWF5YmVTaGFwZTxUPiB7XG4gIC8qKiBEaXN0aW5ndWlzaCBiZXR3ZWVuIHRoZSBgSnVzdGAgYW5kIGBOb3RoaW5nYCBbdmFyaWFudHNdKC4uL2VudW1zL19tYXliZV8udmFyaWFudCkuICovXG4gIHJlYWRvbmx5IHZhcmlhbnQ6IFZhcmlhbnQ7XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmlzSnVzdGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2lzanVzdCkgKi9cbiAgaXNKdXN0KHRoaXM6IE1heWJlPFQ+KTogdGhpcyBpcyBKdXN0PFQ+O1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5pc05vdGhpbmdgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNpc25vdGhpbmcpICovXG4gIGlzTm90aGluZyh0aGlzOiBNYXliZTxUPik6IHRoaXMgaXMgTm90aGluZzxUPjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUubWFwYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjbWFwKSAqL1xuICBtYXA8VT4odGhpczogTWF5YmU8VD4sIG1hcEZuOiAodDogVCkgPT4gVSk6IE1heWJlPFU+O1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5tYXBPcmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI21hcG9yKSAqL1xuICBtYXBPcjxVPih0aGlzOiBNYXliZTxUPiwgb3JVOiBVLCBtYXBGbjogKHQ6IFQpID0+IFUpOiBVO1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5tYXBPckVsc2VgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNtYXBvcmVsc2UpICovXG4gIG1hcE9yRWxzZTxVPih0aGlzOiBNYXliZTxUPiwgb3JFbHNlRm46ICgpID0+IFUsIG1hcEZuOiAodDogVCkgPT4gVSk6IFU7XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLm1hdGNoYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjbWF0Y2gpICovXG4gIG1hdGNoPFU+KHRoaXM6IE1heWJlPFQ+LCBtYXRjaGVyOiBNYXRjaGVyPFQsIFU+KTogVTtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUub3JgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNvcikgKi9cbiAgb3IodGhpczogTWF5YmU8VD4sIG1PcjogTWF5YmU8VD4pOiBNYXliZTxUPjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUub3JFbHNlYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjb3JlbHNlKSAqL1xuICBvckVsc2UodGhpczogTWF5YmU8VD4sIG9yRWxzZUZuOiAoKSA9PiBNYXliZTxUPik6IE1heWJlPFQ+O1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5hbmRgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNhbmQpICovXG4gIGFuZDxVPih0aGlzOiBNYXliZTxUPiwgbUFuZDogTWF5YmU8VT4pOiBNYXliZTxVPjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuYW5kVGhlbmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2FuZHRoZW4pICovXG4gIGFuZFRoZW48VT4odGhpczogTWF5YmU8VD4sIGFuZFRoZW5GbjogKHQ6IFQpID0+IE1heWJlPFU+KTogTWF5YmU8VT47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmNoYWluYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjY2hhaW4pICovXG4gIGNoYWluPFU+KHRoaXM6IE1heWJlPFQ+LCBjaGFpbkZuOiAodDogVCkgPT4gTWF5YmU8VT4pOiBNYXliZTxVPjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuZmxhdE1hcGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2ZsYXRtYXApICovXG4gIGZsYXRNYXA8VT4odGhpczogTWF5YmU8VD4sIGZsYXRNYXBGbjogKHQ6IFQpID0+IE1heWJlPFU+KTogTWF5YmU8VT47XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLnVud3JhcGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI3Vud3JhcCkgKi9cbiAgdW5zYWZlbHlVbndyYXAoKTogVCB8IG5ldmVyO1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS51bndyYXBPckVsc2VgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN1bndyYXBvcmVsc2UpICovXG4gIHVud3JhcE9yRWxzZSh0aGlzOiBNYXliZTxUPiwgZWxzZUZuOiAoKSA9PiBUKTogVDtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUudG9Pa09yRXJyYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjdG9va29yZXJyKSAqL1xuICB0b09rT3JFcnI8RT4odGhpczogTWF5YmU8VD4sIGVycm9yOiBFKTogUmVzdWx0PFQsIEU+O1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS50b09rT3JFbHNlRXJyYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjdG9va29yZWxzZWVycikgKi9cbiAgdG9Pa09yRWxzZUVycjxFPih0aGlzOiBNYXliZTxUPiwgZWxzZUZuOiAoKSA9PiBFKTogUmVzdWx0PFQsIEU+O1xuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS50b1N0cmluZ2BdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI3Rvc3RyaW5nKSAqL1xuICB0b1N0cmluZyh0aGlzOiBNYXliZTxUPik6IHN0cmluZztcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuZXF1YWxzYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjZXF1YWxzKSAqL1xuICBlcXVhbHModGhpczogTWF5YmU8VD4sIGNvbXBhcmlzb246IE1heWJlPFQ+KTogYm9vbGVhbjtcblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuYXBgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNhcCkgKi9cbiAgYXA8VT4odGhpczogTWF5YmU8KHZhbDogVCkgPT4gVT4sIHZhbDogTWF5YmU8VD4pOiBNYXliZTxVPjtcblxuICAvKipcbiAgICBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5nZXRgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNwcm9wKVxuXG4gICAgICAgIElmIHlvdSBoYXZlIGEgYE1heWJlYCBvZiBhbiBvYmplY3QgdHlwZSwgeW91IGNhbiBkbyBgdGhhdE1heWJlLmdldCgnYSBrZXknKWBcbiAgICB0byBsb29rIHVwIHRoZSBuZXh0IGxheWVyIGRvd24gaW4gdGhlIG9iamVjdC5cblxuICAgIGBgYHRzXG4gICAgdHlwZSBEZWVwT3B0aW9uYWxUeXBlID0ge1xuICAgICAgc29tZXRoaW5nPzoge1xuICAgICAgICB3aXRoPzoge1xuICAgICAgICAgIGRlZXBlcktleXM/OiBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgZnVsbHlTZXQ6IERlZXBUeXBlID0ge1xuICAgICAgc29tZXRoaW5nOiB7XG4gICAgICAgIHdpdGg6IHtcbiAgICAgICAgICBkZWVwZXJLZXlzOiAnbGlrZSB0aGlzJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGRlZXBKdXN0ID0gTWF5YmUub2YoZnVsbHlTZXQpXG4gICAgICAuZ2V0KCdzb21ldGhpbmcnKVxuICAgICAgLmdldCgnd2l0aCcpXG4gICAgICAuZ2V0KCdkZWVwZXJLZXlzJyk7XG5cbiAgICBjb25zb2xlLmxvZyhkZWVwSnVzdCk7IC8vIEp1c3QoJ2xpa2UgdGhpcycpO1xuXG4gICAgY29uc3QgcGFydGlhbGx5VW5zZXQ6IERlZXBUeXBlID0geyBzb21ldGhpbmc6IHsgfSB9O1xuXG4gICAgY29uc3QgZGVlcEVtcHR5ID0gTWF5YmUub2YocGFydGlhbGx5VW5zZXQpXG4gICAgICAuZ2V0KCdzb21ldGhpbmcnKVxuICAgICAgLmdldCgnd2l0aCcpXG4gICAgICAuZ2V0KCdkZWVwZXJLZXlzJyk7XG5cbiAgICBjb25zb2xlLmxvZyhkZWVwRW1wdHkpOyAvLyBOb3RoaW5nXG4gICAgYGBgXG4gICAqL1xuICBnZXQ8SyBleHRlbmRzIGtleW9mIFQ+KHRoaXM6IE1heWJlPFQ+LCBrZXk6IEspOiBNYXliZTxSZXF1aXJlZDxUPltLXT47XG59XG5cbi8qKlxuICBBIGBKdXN0YCBpbnN0YW5jZSBpcyB0aGUgKnByZXNlbnQqIHZhcmlhbnQgaW5zdGFuY2Ugb2YgdGhlXG4gIFtgTWF5YmVgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNtYXliZSkgdHlwZSwgcmVwcmVzZW50aW5nIHRoZSBwcmVzZW5jZSBvZiBhXG4gIHZhbHVlIHdoaWNoIG1heSBiZSBhYnNlbnQuIEZvciBhIGZ1bGwgZGlzY3Vzc2lvbiwgc2VlIFt0aGUgbW9kdWxlXG4gIGRvY3NdKC4uL21vZHVsZXMvX21heWJlXy5odG1sKS5cblxuICBAdHlwZXBhcmFtIFQgVGhlIHR5cGUgd3JhcHBlZCBpbiB0aGlzIGBKdXN0YCB2YXJpYW50IG9mIGBNYXliZWAuXG4gKi9cbmV4cG9ydCBjbGFzcyBKdXN0PFQ+IGltcGxlbWVudHMgTWF5YmVTaGFwZTxUPiB7XG4gIC8qKlxuICAgIFVud3JhcCB0aGUgY29udGFpbmVkIHZhbHVlLiBBIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgZnVuY3Rpb25hbCBpZGlvbXMuXG5cbiAgICBBIGNvbW1vbiBzY2VuYXJpbyB3aGVyZSB5b3UgbWlnaHQgd2FudCB0byB1c2UgdGhpcyBpcyBpbiBhIHBpcGVsaW5lIG9mXG4gICAgZnVuY3Rpb25zOlxuXG4gICAgYGBgdHNcbiAgICBpbXBvcnQgTWF5YmUsIHsgSnVzdCB9IGZyb20gJ3RydWUtbXl0aC9tYXliZSc7XG5cbiAgICBmdW5jdGlvbiBnZXRMZW5ndGhzKG1heWJlU3RyaW5nczogQXJyYXk8TWF5YmU8c3RyaW5nPj4pOiBBcnJheTxudW1iZXI+IHtcbiAgICAgIHJldHVybiBtYXliZVN0cmluZ3NcbiAgICAgICAgLmZpbHRlcihNYXliZS5pc0p1c3QpXG4gICAgICAgIC5tYXAoSnVzdC51bndyYXApXG4gICAgICAgIC5tYXAocyA9PiBzLmxlbmd0aCk7XG4gICAgfVxuICAgIGBgYFxuICAgKi9cbiAgc3RhdGljIHVud3JhcDxKPih0aGVKdXN0OiBKdXN0PEo+KTogSiB7XG4gICAgcmV0dXJuIHRoZUp1c3QudmFsdWU7XG4gIH1cblxuICAvKiogYEp1c3RgIGlzIGFsd2F5cyBbYFZhcmlhbnQuSnVzdGBdKC4uL2VudW1zL19tYXliZV8udmFyaWFudCNqdXN0KS4gKi9cbiAgcmVhZG9ubHkgdmFyaWFudDogVmFyaWFudC5KdXN0ID0gVmFyaWFudC5KdXN0O1xuXG4gIC8qKiBUaGUgd3JhcHBlZCB2YWx1ZS4gKi9cbiAgcmVhZG9ubHkgdmFsdWU6IFQ7XG5cbiAgLyoqXG4gICAgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIGBNYXliZS5KdXN0YCB3aXRoIGBuZXdgLlxuXG4gICAgQG5vdGUgV2hpbGUgeW91ICptYXkqIGNyZWF0ZSB0aGUgYEp1c3RgIHR5cGUgdmlhIG5vcm1hbCBKYXZhU2NyaXB0XG4gICAgY2xhc3MgY29uc3RydWN0aW9uLCBpdCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHRoZSBmdW5jdGlvbmFsIHN0eWxlIGZvclxuICAgIHdoaWNoIHRoZSBsaWJyYXJ5IGlzIGludGVuZGVkLiBJbnN0ZWFkLCB1c2UgW2BNYXliZS5vZmBdIChmb3IgdGhlIGdlbmVyYWxcbiAgICBjYXNlKSBvciBbYE1heWJlLmp1c3RgXSBmb3IgdGhpcyBzcGVjaWZpYyBjYXNlLlxuXG4gICAgW2BNYXliZS5vZmBdOiAuLi9tb2R1bGVzL19tYXliZV8uaHRtbCNvZlxuICAgIFtgTWF5YmUuanVzdGBdOiAuLi9tb2R1bGVzL19tYXliZV8uaHRtbCNqdXN0XG5cbiAgICBgYGB0c1xuICAgIC8vIEF2b2lkOlxuICAgIGNvbnN0IGFTdHJpbmcgPSBuZXcgTWF5YmUuSnVzdCgnY2hhcmFjdGVycycpO1xuXG4gICAgLy8gUHJlZmVyOlxuICAgIGNvbnN0IGFTdHJpbmcgPSBNYXliZS5qdXN0KCdjaGFyYWN0ZXJzKTtcbiAgICBgYGBcblxuICAgIEBwYXJhbSB2YWx1ZVxuICAgIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYE1heWJlLkp1c3RgLlxuXG4gICAgYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBhcmUgYWxsb3dlZCBieSB0aGUgdHlwZSBzaWduYXR1cmUgc28gdGhhdCB0aGVcbiAgICBjb25zdHJ1Y3RvciBtYXkgYHRocm93YCBvbiB0aG9zZSByYXRoZXIgdGhhbiBjb25zdHJ1Y3RpbmcgYSB0eXBlIGxpa2VcbiAgICBgTWF5YmU8dW5kZWZpbmVkPmAuXG5cbiAgICBAdGhyb3dzICAgICAgSWYgeW91IHBhc3MgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgY29uc3RydWN0b3IodmFsdWU/OiBUIHwgbnVsbCkge1xuICAgIGlmIChpc1ZvaWQodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWVkIHRvIGNvbnN0cnVjdCBgSnVzdGAgd2l0aCBgbnVsbGAgb3IgYHVuZGVmaW5lZGAnKTtcbiAgICB9XG5cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuaXNKdXN0YF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjaXNqdXN0KSAqL1xuICBpc0p1c3QodGhpczogTWF5YmU8VD4pOiB0aGlzIGlzIEp1c3Q8VD4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmlzTm90aGluZ2BdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2lzbm90aGluZykgKi9cbiAgaXNOb3RoaW5nKHRoaXM6IE1heWJlPFQ+KTogdGhpcyBpcyBOb3RoaW5nPFQ+IHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUubWFwYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjbWFwKSAqL1xuICBtYXA8VT4odGhpczogTWF5YmU8VD4sIG1hcEZuOiAodDogVCkgPT4gVSk6IE1heWJlPFU+IHtcbiAgICByZXR1cm4gbWFwKG1hcEZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5tYXBPcmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI21hcG9yKSAqL1xuICBtYXBPcjxVPih0aGlzOiBNYXliZTxUPiwgb3JVOiBVLCBtYXBGbjogKHQ6IFQpID0+IFUpOiBVIHtcbiAgICByZXR1cm4gbWFwT3Iob3JVLCBtYXBGbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUubWFwT3JFbHNlYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjbWFwb3JlbHNlKSAqL1xuICBtYXBPckVsc2U8VT4odGhpczogTWF5YmU8VD4sIG9yRWxzZUZuOiAoKSA9PiBVLCBtYXBGbjogKHQ6IFQpID0+IFUpOiBVIHtcbiAgICByZXR1cm4gbWFwT3JFbHNlKG9yRWxzZUZuLCBtYXBGbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUubWF0Y2hgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNtYXRjaCkgKi9cbiAgbWF0Y2g8VT4odGhpczogTWF5YmU8VD4sIG1hdGNoZXI6IE1hdGNoZXI8VCwgVT4pOiBVIHtcbiAgICByZXR1cm4gbWF0Y2gobWF0Y2hlciwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUub3JgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNvcikgKi9cbiAgb3IodGhpczogTWF5YmU8VD4sIG1PcjogTWF5YmU8VD4pOiBNYXliZTxUPiB7XG4gICAgcmV0dXJuIG9yKG1PciwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUub3JFbHNlYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjb3JlbHNlKSAqL1xuICBvckVsc2UodGhpczogTWF5YmU8VD4sIG9yRWxzZUZuOiAoKSA9PiBNYXliZTxUPik6IE1heWJlPFQ+IHtcbiAgICByZXR1cm4gb3JFbHNlKG9yRWxzZUZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5hbmRgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNhbmQpICovXG4gIGFuZDxVPih0aGlzOiBNYXliZTxUPiwgbUFuZDogTWF5YmU8VT4pOiBNYXliZTxVPiB7XG4gICAgcmV0dXJuIGFuZChtQW5kLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5hbmRUaGVuYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjYW5kdGhlbikgKi9cbiAgYW5kVGhlbjxVPih0aGlzOiBNYXliZTxUPiwgYW5kVGhlbkZuOiAodDogVCkgPT4gTWF5YmU8VT4pOiBNYXliZTxVPiB7XG4gICAgcmV0dXJuIGFuZFRoZW4oYW5kVGhlbkZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5jaGFpbmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2NoYWluKSAqL1xuICBjaGFpbjxVPih0aGlzOiBNYXliZTxUPiwgY2hhaW5GbjogKHQ6IFQpID0+IE1heWJlPFU+KTogTWF5YmU8VT4ge1xuICAgIHJldHVybiB0aGlzLmFuZFRoZW4oY2hhaW5Gbik7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuZmxhdE1hcGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2ZsYXRtYXApICovXG4gIGZsYXRNYXA8VT4odGhpczogTWF5YmU8VD4sIGZsYXRNYXBGbjogKHQ6IFQpID0+IE1heWJlPFU+KTogTWF5YmU8VT4ge1xuICAgIHJldHVybiB0aGlzLmFuZFRoZW4oZmxhdE1hcEZuKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS51bnNhZmVseVVud3JhcGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI3Vuc2FmZWx5dW53cmFwKSAqL1xuICB1bnNhZmVseVVud3JhcCgpOiBUIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS51bndyYXBPcmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI3Vud3JhcG9yKSAqL1xuICB1bndyYXBPcih0aGlzOiBNYXliZTxUPiwgZGVmYXVsdFZhbHVlOiBUKTogVCB7XG4gICAgcmV0dXJuIHVud3JhcE9yKGRlZmF1bHRWYWx1ZSwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUudW53cmFwT3JFbHNlYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjdW53cmFwb3JlbHNlKSAqL1xuICB1bndyYXBPckVsc2UodGhpczogTWF5YmU8VD4sIGVsc2VGbjogKCkgPT4gVCk6IFQge1xuICAgIHJldHVybiB1bndyYXBPckVsc2UoZWxzZUZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS50b09rT3JFcnJgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN0b29rb3JlcnIpICovXG4gIHRvT2tPckVycjxFPih0aGlzOiBNYXliZTxUPiwgZXJyb3I6IEUpOiBSZXN1bHQ8VCwgRT4ge1xuICAgIHJldHVybiB0b09rT3JFcnIoZXJyb3IsIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLnRvT2tPckVsc2VFcnJgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN0b29rb3JlbHNlZXJyKSAqL1xuICB0b09rT3JFbHNlRXJyPEU+KHRoaXM6IE1heWJlPFQ+LCBlbHNlRm46ICgpID0+IEUpOiBSZXN1bHQ8VCwgRT4ge1xuICAgIHJldHVybiB0b09rT3JFbHNlRXJyKGVsc2VGbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUudG9TdHJpbmdgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN0b3N0cmluZykgKi9cbiAgdG9TdHJpbmcodGhpczogTWF5YmU8VD4pOiBzdHJpbmcge1xuICAgIHJldHVybiB0b1N0cmluZyh0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5lcXVhbHNgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNlcXVhbHMpICovXG4gIGVxdWFscyh0aGlzOiBNYXliZTxUPiwgY29tcGFyaXNvbjogTWF5YmU8VD4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gZXF1YWxzKGNvbXBhcmlzb24sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmFwYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjYXApICovXG4gIGFwPEEsIEI+KHRoaXM6IE1heWJlPCh2YWw6IEEpID0+IEI+LCB2YWw6IE1heWJlPEE+KTogTWF5YmU8Qj4ge1xuICAgIHJldHVybiBhcCh0aGlzLCB2YWwpO1xuICB9XG5cbiAgLyoqXG4gICAgTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuZ2V0YF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjcHJvcClcblxuICAgICAgICBJZiB5b3UgaGF2ZSBhIGBNYXliZWAgb2YgYW4gb2JqZWN0IHR5cGUsIHlvdSBjYW4gZG8gYHRoYXRNYXliZS5nZXQoJ2Ega2V5JylgXG4gICAgdG8gbG9vayB1cCB0aGUgbmV4dCBsYXllciBkb3duIGluIHRoZSBvYmplY3QuXG5cbiAgICBgYGB0c1xuICAgIHR5cGUgRGVlcE9wdGlvbmFsVHlwZSA9IHtcbiAgICAgIHNvbWV0aGluZz86IHtcbiAgICAgICAgd2l0aD86IHtcbiAgICAgICAgICBkZWVwZXJLZXlzPzogc3RyaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGZ1bGx5U2V0OiBEZWVwVHlwZSA9IHtcbiAgICAgIHNvbWV0aGluZzoge1xuICAgICAgICB3aXRoOiB7XG4gICAgICAgICAgZGVlcGVyS2V5czogJ2xpa2UgdGhpcydcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBkZWVwSnVzdCA9IE1heWJlLm9mKGZ1bGx5U2V0KVxuICAgICAgLmdldCgnc29tZXRoaW5nJylcbiAgICAgIC5nZXQoJ3dpdGgnKVxuICAgICAgLmdldCgnZGVlcGVyS2V5cycpO1xuXG4gICAgY29uc29sZS5sb2coZGVlcEp1c3QpOyAvLyBKdXN0KCdsaWtlIHRoaXMnKTtcblxuICAgIGNvbnN0IHBhcnRpYWxseVVuc2V0OiBEZWVwVHlwZSA9IHsgc29tZXRoaW5nOiB7IH0gfTtcblxuICAgIGNvbnN0IGRlZXBFbXB0eSA9IE1heWJlLm9mKHBhcnRpYWxseVVuc2V0KVxuICAgICAgLmdldCgnc29tZXRoaW5nJylcbiAgICAgIC5nZXQoJ3dpdGgnKVxuICAgICAgLmdldCgnZGVlcGVyS2V5cycpO1xuXG4gICAgY29uc29sZS5sb2coZGVlcEVtcHR5KTsgLy8gTm90aGluZ1xuICAgIGBgYFxuICAgKi9cbiAgZ2V0PEsgZXh0ZW5kcyBrZXlvZiBUPih0aGlzOiBNYXliZTxUPiwga2V5OiBLKTogTWF5YmU8UmVxdWlyZWQ8VD5bS10+IHtcbiAgICByZXR1cm4gdGhpcy5hbmRUaGVuKHByb3BlcnR5KGtleSkpO1xuICB9XG59XG5cbi8qKlxuICBBIGBOb3RoaW5nYCBpbnN0YW5jZSBpcyB0aGUgKmFic2VudCogdmFyaWFudCBpbnN0YW5jZSBvZiB0aGVcbiAgW2BNYXliZWBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI21heWJlKSB0eXBlLCByZXByZXNlbnRpbmcgdGhlIHByZXNlbmNlIG9mIGFcbiAgdmFsdWUgd2hpY2ggbWF5IGJlIGFic2VudC4gRm9yIGEgZnVsbCBkaXNjdXNzaW9uLCBzZWUgW3RoZSBtb2R1bGVcbiAgZG9jc10oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwpLlxuXG4gIEB0eXBlcGFyYW0gVCBUaGUgdHlwZSB3aGljaCB3b3VsZCBiZSB3cmFwcGVkIGluIGEgYEp1c3RgIHZhcmlhbnQgb2YgYE1heWJlYC5cbiAqL1xuZXhwb3J0IGNsYXNzIE5vdGhpbmc8VD4gaW1wbGVtZW50cyBNYXliZVNoYXBlPFQ+IHtcbiAgLyoqIGBOb3RoaW5nYCBpcyBhbHdheXMgW2BWYXJpYW50Lk5vdGhpbmdgXSguLi9lbnVtcy9fbWF5YmVfLnZhcmlhbnQjbm90aGluZykuICovXG4gIHJlYWRvbmx5IHZhcmlhbnQ6IFZhcmlhbnQuTm90aGluZyA9IFZhcmlhbnQuTm90aGluZztcblxuICAvKipcbiAgICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYE1heWJlLk5vdGhpbmdgIHdpdGggYG5ld2AuXG5cbiAgICBAbm90ZSBXaGlsZSB5b3UgKm1heSogY3JlYXRlIHRoZSBgTm90aGluZ2AgdHlwZSB2aWEgbm9ybWFsIEphdmFTY3JpcHRcbiAgICBjbGFzcyBjb25zdHJ1Y3Rpb24sIGl0IGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdGhlIGZ1bmN0aW9uYWwgc3R5bGUgZm9yXG4gICAgd2hpY2ggdGhlIGxpYnJhcnkgaXMgaW50ZW5kZWQuIEluc3RlYWQsIHVzZSBbYE1heWJlLm9mYF0gKGZvciB0aGUgZ2VuZXJhbFxuICAgIGNhc2UpIG9yIFtgTWF5YmUubm90aGluZ2BdIGZvciB0aGlzIHNwZWNpZmljIGNhc2UuXG5cbiAgICBbYE1heWJlLm9mYF06IC4uL21vZHVsZXMvX21heWJlXy5odG1sI29mXG4gICAgW2BNYXliZS5ub3RoaW5nYF06IC4uL21vZHVsZXMvX21heWJlXy5odG1sI25vdGhpbmdcblxuICAgIGBgYHRzXG4gICAgLy8gQXZvaWQ6XG4gICAgY29uc3QgYU5vdGhpbmcgPSBuZXcgTWF5YmUuRXJyKCk7XG5cbiAgICAvLyBQcmVmZXI6XG4gICAgY29uc3QgYU5vdGhpbmcgPSBNYXliZS5ub3RoaW5nKCk7XG4gICAgYGBgXG5cbiAgICBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGFyZSBhbGxvd2VkIHNvIHRoYXQgeW91IG1heSBleHBsaWNpdGx5IGNvbnN0cnVjdCB0aGVcbiAgICBgRXJyYCB0eXBlIHdpdGggYSBrbm93biBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgdmFsdWUuIChUaGlzIG1heWJlIGhlbHBmdWxcbiAgICBwcmltYXJpbHkgd2hlbiB0cmFuc2l0aW9uaW5nIGEgY29kZWJhc2UgdG8gdGhlIHVzZSBvZiBgTWF5YmVgLilcblxuICAgIEB0aHJvd3MgICAgICBJZiB5b3UgcGFzcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihfPzogbnVsbCkge1xuICAgIC8qIG5vdGhpbmcgdG8gZG8gKi9cbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5pc0p1c3RgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNpc2p1c3QpICovXG4gIGlzSnVzdCh0aGlzOiBNYXliZTxUPik6IHRoaXMgaXMgSnVzdDxUPiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmlzTm90aGluZ2BdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2lzbm90aGluZykgKi9cbiAgaXNOb3RoaW5nKHRoaXM6IE1heWJlPFQ+KTogdGhpcyBpcyBOb3RoaW5nPFQ+IHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5tYXBgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNtYXApICovXG4gIG1hcDxVPih0aGlzOiBNYXliZTxUPiwgbWFwRm46ICh0OiBUKSA9PiBVKTogTWF5YmU8VT4ge1xuICAgIHJldHVybiBtYXAobWFwRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLm1hcE9yYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjbWFwb3IpICovXG4gIG1hcE9yPFU+KHRoaXM6IE1heWJlPFQ+LCBvclU6IFUsIG1hcEZuOiAodDogVCkgPT4gVSk6IFUge1xuICAgIHJldHVybiBtYXBPcihvclUsIG1hcEZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5tYXBPckVsc2VgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNtYXBvcmVsc2UpICovXG4gIG1hcE9yRWxzZTxVPih0aGlzOiBNYXliZTxUPiwgb3JFbHNlRm46ICgpID0+IFUsIG1hcEZuOiAodDogVCkgPT4gVSk6IFUge1xuICAgIHJldHVybiBtYXBPckVsc2Uob3JFbHNlRm4sIG1hcEZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5tYXRjaGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI21hdGNoKSAqL1xuICBtYXRjaDxVPih0aGlzOiBNYXliZTxUPiwgbWF0Y2hlcjogTWF0Y2hlcjxULCBVPik6IFUge1xuICAgIHJldHVybiBtYXRjaChtYXRjaGVyLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5vcmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI29yKSAqL1xuICBvcih0aGlzOiBNYXliZTxUPiwgbU9yOiBNYXliZTxUPik6IE1heWJlPFQ+IHtcbiAgICByZXR1cm4gb3IobU9yLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5vckVsc2VgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNvcmVsc2UpICovXG4gIG9yRWxzZSh0aGlzOiBNYXliZTxUPiwgb3JFbHNlRm46ICgpID0+IE1heWJlPFQ+KTogTWF5YmU8VD4ge1xuICAgIHJldHVybiBvckVsc2Uob3JFbHNlRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmFuZGBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI2FuZCkgKi9cbiAgYW5kPFU+KHRoaXM6IE1heWJlPFQ+LCBtQW5kOiBNYXliZTxVPik6IE1heWJlPFU+IHtcbiAgICByZXR1cm4gYW5kKG1BbmQsIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmFuZFRoZW5gXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNhbmR0aGVuKSAqL1xuICBhbmRUaGVuPFU+KHRoaXM6IE1heWJlPFQ+LCBhbmRUaGVuRm46ICh0OiBUKSA9PiBNYXliZTxVPik6IE1heWJlPFU+IHtcbiAgICByZXR1cm4gYW5kVGhlbihhbmRUaGVuRm4sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmNoYWluYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjY2hhaW4pICovXG4gIGNoYWluPFU+KHRoaXM6IE1heWJlPFQ+LCBjaGFpbkZuOiAodDogVCkgPT4gTWF5YmU8VT4pOiBNYXliZTxVPiB7XG4gICAgcmV0dXJuIHRoaXMuYW5kVGhlbihjaGFpbkZuKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5mbGF0TWFwYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjZmxhdG1hcCkgKi9cbiAgZmxhdE1hcDxVPih0aGlzOiBNYXliZTxUPiwgZmxhdE1hcEZuOiAodDogVCkgPT4gTWF5YmU8VT4pOiBNYXliZTxVPiB7XG4gICAgcmV0dXJuIHRoaXMuYW5kVGhlbihmbGF0TWFwRm4pO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLnVuc2FmZWx5VW53cmFwYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjdW5zYWZlbHl1bndyYXApICovXG4gIHVuc2FmZWx5VW53cmFwKCk6IG5ldmVyIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWVkIHRvIGB1bnNhZmVseVVud3JhcChOb3RoaW5nKWAnKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS51bndyYXBPcmBdKC4uL21vZHVsZXMvX21heWJlXy5odG1sI3Vud3JhcG9yKSAqL1xuICB1bndyYXBPcih0aGlzOiBNYXliZTxUPiwgZGVmYXVsdFZhbHVlOiBUKTogVCB7XG4gICAgcmV0dXJuIHVud3JhcE9yKGRlZmF1bHRWYWx1ZSwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUudW53cmFwT3JFbHNlYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjdW53cmFwb3JlbHNlKSAqL1xuICB1bndyYXBPckVsc2UodGhpczogTWF5YmU8VD4sIGVsc2VGbjogKCkgPT4gVCk6IFQge1xuICAgIHJldHVybiB1bndyYXBPckVsc2UoZWxzZUZuLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS50b09rT3JFcnJgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN0b29rb3JlcnIpICovXG4gIHRvT2tPckVycjxFPih0aGlzOiBNYXliZTxUPiwgZXJyb3I6IEUpOiBSZXN1bHQ8VCwgRT4ge1xuICAgIHJldHVybiB0b09rT3JFcnIoZXJyb3IsIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLnRvT2tPckVsc2VFcnJgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN0b29rb3JlbHNlZXJyKSAqL1xuICB0b09rT3JFbHNlRXJyPEU+KHRoaXM6IE1heWJlPFQ+LCBlbHNlRm46ICgpID0+IEUpOiBSZXN1bHQ8VCwgRT4ge1xuICAgIHJldHVybiB0b09rT3JFbHNlRXJyKGVsc2VGbiwgdGhpcyk7XG4gIH1cblxuICAvKiogTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUudG9TdHJpbmdgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCN0b3N0cmluZykgKi9cbiAgdG9TdHJpbmcodGhpczogTWF5YmU8VD4pOiBzdHJpbmcge1xuICAgIHJldHVybiB0b1N0cmluZyh0aGlzKTtcbiAgfVxuXG4gIC8qKiBNZXRob2QgdmFyaWFudCBmb3IgW2BNYXliZS5lcXVhbHNgXSguLi9tb2R1bGVzL19tYXliZV8uaHRtbCNlcXVhbHMpICovXG4gIGVxdWFscyh0aGlzOiBNYXliZTxUPiwgY29tcGFyaXNvbjogTWF5YmU8VD4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gZXF1YWxzKGNvbXBhcmlzb24sIHRoaXMpO1xuICB9XG5cbiAgLyoqIE1ldGhvZCB2YXJpYW50IGZvciBbYE1heWJlLmFwYF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjYXApICovXG4gIGFwPEEsIEI+KHRoaXM6IE1heWJlPCh2YWw6IEEpID0+IEI+LCB2YWw6IE1heWJlPEE+KTogTWF5YmU8Qj4ge1xuICAgIHJldHVybiBhcCh0aGlzLCB2YWwpO1xuICB9XG5cbiAgLyoqXG4gICAgTWV0aG9kIHZhcmlhbnQgZm9yIFtgTWF5YmUuZ2V0YF0oLi4vbW9kdWxlcy9fbWF5YmVfLmh0bWwjcHJvcClcblxuICAgICAgICBJZiB5b3UgaGF2ZSBhIGBNYXliZWAgb2YgYW4gb2JqZWN0IHR5cGUsIHlvdSBjYW4gZG8gYHRoYXRNYXliZS5nZXQoJ2Ega2V5JylgXG4gICAgdG8gbG9vayB1cCB0aGUgbmV4dCBsYXllciBkb3duIGluIHRoZSBvYmplY3QuXG5cbiAgICBgYGB0c1xuICAgIHR5cGUgRGVlcE9wdGlvbmFsVHlwZSA9IHtcbiAgICAgIHNvbWV0aGluZz86IHtcbiAgICAgICAgd2l0aD86IHtcbiAgICAgICAgICBkZWVwZXJLZXlzPzogc3RyaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGZ1bGx5U2V0OiBEZWVwVHlwZSA9IHtcbiAgICAgIHNvbWV0aGluZzoge1xuICAgICAgICB3aXRoOiB7XG4gICAgICAgICAgZGVlcGVyS2V5czogJ2xpa2UgdGhpcydcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBkZWVwSnVzdCA9IE1heWJlLm9mKGZ1bGx5U2V0KVxuICAgICAgLmdldCgnc29tZXRoaW5nJylcbiAgICAgIC5nZXQoJ3dpdGgnKVxuICAgICAgLmdldCgnZGVlcGVyS2V5cycpO1xuXG4gICAgY29uc29sZS5sb2coZGVlcEp1c3QpOyAvLyBKdXN0KCdsaWtlIHRoaXMnKTtcblxuICAgIGNvbnN0IHBhcnRpYWxseVVuc2V0OiBEZWVwVHlwZSA9IHsgc29tZXRoaW5nOiB7IH0gfTtcblxuICAgIGNvbnN0IGRlZXBFbXB0eSA9IE1heWJlLm9mKHBhcnRpYWxseVVuc2V0KVxuICAgICAgLmdldCgnc29tZXRoaW5nJylcbiAgICAgIC5nZXQoJ3dpdGgnKVxuICAgICAgLmdldCgnZGVlcGVyS2V5cycpO1xuXG4gICAgY29uc29sZS5sb2coZGVlcEVtcHR5KTsgLy8gTm90aGluZ1xuICAgIGBgYFxuICAgKi9cbiAgZ2V0PEsgZXh0ZW5kcyBrZXlvZiBUPih0aGlzOiBNYXliZTxUPiwga2V5OiBLKTogTWF5YmU8UmVxdWlyZWQ8VD5bS10+IHtcbiAgICByZXR1cm4gdGhpcy5hbmRUaGVuKHByb3BlcnR5KGtleSkpO1xuICB9XG59XG5cbi8qKlxuICBJcyB0aGlzIHJlc3VsdCBhIGBKdXN0YCBpbnN0YW5jZT9cblxuICBAdHlwZXBhcmFtIFQgVGhlIHR5cGUgb2YgdGhlIHdyYXBwZWQgdmFsdWUuXG4gIEBwYXJhbSBtYXliZSBUaGUgYE1heWJlYCBpbnN0YW5jZSB0byBjaGVjay5cbiAgQHJldHVybnMgICAgIGB0cnVlYCBpZiBgbWF5YmVgIGlzIGBKdXN0YCwgYGZhbHNlYCBvdGhlcndpc2UuIEluIFR5cGVTY3JpcHQsXG4gICAgICAgICAgICAgICBhbHNvIG5hcnJvd3MgdGhlIHR5cGUgZnJvbSBgTWF5YmU8VD5gIHRvIGBKdXN0PFQ+YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSnVzdDxUPihtYXliZTogTWF5YmU8VD4pOiBtYXliZSBpcyBKdXN0PFQ+IHtcbiAgcmV0dXJuIG1heWJlLnZhcmlhbnQgPT09IFZhcmlhbnQuSnVzdDtcbn1cblxuLyoqXG4gIElzIHRoaXMgcmVzdWx0IGEgYE5vdGhpbmdgIGluc3RhbmNlP1xuXG4gIEB0eXBlcGFyYW0gVCBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgQHBhcmFtIG1heWJlIFRoZSBgTWF5YmVgIGluc3RhbmNlIHRvIGNoZWNrLlxuICBAcmV0dXJucyAgICAgYHRydWVgIGlmIGBtYXliZWAgaXMgYG5vdGhpbmdgLCBgZmFsc2VgIG90aGVyd2lzZS4gSW4gVHlwZVNjcmlwdCxcbiAgICAgICAgICAgICAgIGFsc28gbmFycm93cyB0aGUgdHlwZSBmcm9tIGBNYXliZTxUPmAgdG8gYE5vdGhpbmc8VD5gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOb3RoaW5nPFQ+KG1heWJlOiBNYXliZTxUPik6IG1heWJlIGlzIE5vdGhpbmc8VD4ge1xuICByZXR1cm4gbWF5YmUudmFyaWFudCA9PT0gVmFyaWFudC5Ob3RoaW5nO1xufVxuXG4vKipcbiAgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIGBNYXliZS5KdXN0YC5cblxuICBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGFyZSBhbGxvd2VkIGJ5IHRoZSB0eXBlIHNpZ25hdHVyZSBzbyB0aGF0IHRoZVxuICBmdW5jdGlvbiBtYXkgYHRocm93YCBvbiB0aG9zZSByYXRoZXIgdGhhbiBjb25zdHJ1Y3RpbmcgYSB0eXBlIGxpa2VcbiAgYE1heWJlPHVuZGVmaW5lZD5gLlxuXG4gIEB0eXBlcGFyYW0gVCBUaGUgdHlwZSBvZiB0aGUgaXRlbSBjb250YWluZWQgaW4gdGhlIGBNYXliZWAuXG4gIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBNYXliZS5KdXN0YC5cbiAgQHJldHVybnMgICAgIEFuIGluc3RhbmNlIG9mIGBNYXliZS5KdXN0PFQ+YC5cbiAgQHRocm93cyAgICAgIElmIHlvdSBwYXNzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGp1c3Q8VD4odmFsdWU/OiBUIHwgbnVsbCk6IE1heWJlPFQ+IHtcbiAgcmV0dXJuIG5ldyBKdXN0PFQ+KHZhbHVlKTtcbn1cblxuLyoqXG4gIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBgTWF5YmUuTm90aGluZ2AuXG5cbiAgSWYgeW91IHdhbnQgdG8gY3JlYXRlIGFuIGluc3RhbmNlIHdpdGggYSBzcGVjaWZpYyB0eXBlLCBlLmcuIGZvciB1c2UgaW4gYVxuICBmdW5jdGlvbiB3aGljaCBleHBlY3RzIGEgYE1heWJlPFQ+YCB3aGVyZSB0aGUgYDxUPmAgaXMga25vd24gYnV0IHlvdSBoYXZlIG5vXG4gIHZhbHVlIHRvIGdpdmUgaXQsIHlvdSBjYW4gdXNlIGEgdHlwZSBwYXJhbWV0ZXI6XG5cbiAgYGBgdHNcbiAgY29uc3Qgbm90U3RyaW5nID0gTWF5YmUubm90aGluZzxzdHJpbmc+KCk7XG4gIGBgYFxuXG4gIEB0eXBlcGFyYW0gVCBUaGUgdHlwZSBvZiB0aGUgaXRlbSBjb250YWluZWQgaW4gdGhlIGBNYXliZWAuXG4gIEByZXR1cm5zICAgICBBbiBpbnN0YW5jZSBvZiBgTWF5YmUuTm90aGluZzxUPmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3RoaW5nPFQ+KF8/OiBudWxsKTogTWF5YmU8VD4ge1xuICByZXR1cm4gbmV3IE5vdGhpbmc8VD4oXyk7XG59XG5cbi8qKlxuICBDcmVhdGUgYSBgTWF5YmVgIGZyb20gYW55IHZhbHVlLlxuXG4gIFRvIHNwZWNpZnkgdGhhdCB0aGUgcmVzdWx0IHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBhIHNwZWNpZmljIHR5cGUsIHlvdSBtYXlcbiAgaW52b2tlIGBNYXliZS5vZmAgd2l0aCBhbiBleHBsaWNpdCB0eXBlIHBhcmFtZXRlcjpcblxuICBgYGB0c1xuICBjb25zdCBmb28gPSBNYXliZS5vZjxzdHJpbmc+KG51bGwpO1xuICBgYGBcblxuICBUaGlzIGlzIHVzdWFsbHkgb25seSBpbXBvcnRhbnQgaW4gdHdvIGNhc2VzOlxuXG4gIDEuICBJZiB5b3UgYXJlIGludGVudGlvbmFsbHkgY29uc3RydWN0aW5nIGEgYE5vdGhpbmdgIGZyb20gYSBrbm93biBgbnVsbGAgb3JcbiAgICAgIHVuZGVmaW5lZCB2YWx1ZSAqd2hpY2ggaXMgdW50eXBlZCouXG4gIDIuICBJZiB5b3UgYXJlIHNwZWNpZnlpbmcgdGhhdCB0aGUgdHlwZSBpcyBtb3JlIGdlbmVyYWwgdGhhbiB0aGUgdmFsdWUgcGFzc2VkXG4gICAgICAoc2luY2UgVHlwZVNjcmlwdCBjYW4gZGVmaW5lIHR5cGVzIGFzIGxpdGVyYWxzKS5cblxuICBAdHlwZXBhcmFtIFQgVGhlIHR5cGUgb2YgdGhlIGl0ZW0gY29udGFpbmVkIGluIHRoZSBgTWF5YmVgLlxuICBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgTWF5YmVgLiBJZiBpdCBpcyBgdW5kZWZpbmVkYCBvciBgbnVsbGAsXG4gICAgICAgICAgICAgICB0aGUgcmVzdWx0IHdpbGwgYmUgYE5vdGhpbmdgOyBvdGhlcndpc2UgaXQgd2lsbCBiZSB0aGUgdHlwZSBvZlxuICAgICAgICAgICAgICAgdGhlIHZhbHVlIHBhc3NlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9mPFQ+KHZhbHVlPzogVCB8IG51bGwpOiBNYXliZTxUPiB7XG4gIHJldHVybiBpc1ZvaWQodmFsdWUpID8gbm90aGluZzxUPigpIDoganVzdCh2YWx1ZSk7XG59XG5cbi8qKiBBbGlhcyBmb3IgW2BvZmBdKCNvZiksIHByaW1hcmlseSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEZvbGt0YWxlLiAqL1xuZXhwb3J0IGNvbnN0IGZyb21OdWxsYWJsZSA9IG9mO1xuXG4vKipcbiAgTWFwIG92ZXIgYSBgTWF5YmVgIGluc3RhbmNlOiBhcHBseSB0aGUgZnVuY3Rpb24gdG8gdGhlIHdyYXBwZWQgdmFsdWUgaWYgdGhlXG4gIGluc3RhbmNlIGlzIGBKdXN0YCwgYW5kIHJldHVybiBgTm90aGluZ2AgaWYgdGhlIGluc3RhbmNlIGlzIGBOb3RoaW5nYC5cblxuICBgTWF5YmUubWFwYCB3b3JrcyBhIGxvdCBsaWtlIGBBcnJheS5wcm90b3R5cGUubWFwYDogYE1heWJlYCBhbmQgYEFycmF5YCBhcmVcbiAgYm90aCAqY29udGFpbmVycyogZm9yIG90aGVyIHRoaW5ncy4gSWYgeW91IGhhdmUgbm8gaXRlbXMgaW4gYW4gYXJyYXkgb2ZcbiAgbnVtYmVycyBuYW1lZCBgZm9vYCBhbmQgY2FsbCBgZm9vLm1hcCh4ID0+IHggKyAxKWAsIHlvdSdsbCBzdGlsbCBqdXN0IGhhdmUgYW5cbiAgYXJyYXkgd2l0aCBub3RoaW5nIGluIGl0LiBCdXQgaWYgeW91IGhhdmUgYW55IGl0ZW1zIGluIHRoZSBhcnJheSAoYFsyLCAzXWApLFxuICBhbmQgeW91IGNhbGwgYGZvby5tYXAoeCA9PiB4ICsgMSlgIG9uIGl0LCB5b3UnbGwgZ2V0IGEgbmV3IGFycmF5IHdpdGggZWFjaCBvZlxuICB0aG9zZSBpdGVtcyBpbnNpZGUgdGhlIGFycmF5IFwiY29udGFpbmVyXCIgdHJhbnNmb3JtZWQgKGBbMywgNF1gKS5cblxuICBUaGF0J3MgZXhhY3RseSB3aGF0J3MgaGFwcGVuaW5nIHdpdGggYE1heWJlLm1hcGAuIElmIHRoZSBjb250YWluZXIgaXMgKmVtcHR5KlxuICDigJPCoHRoZSBgTm90aGluZ2AgdmFyaWFudCDigJMgeW91IGp1c3QgZ2V0IGJhY2sgYW4gZW1wdHkgY29udGFpbmVyLiBJZiB0aGVcbiAgY29udGFpbmVyIGhhcyBzb21ldGhpbmcgaW4gaXQg4oCTwqB0aGUgYEp1c3RgIHZhcmlhbnQg4oCTwqB5b3UgZ2V0IGJhY2sgYSBjb250YWluZXJcbiAgd2l0aCB0aGUgaXRlbSBpbnNpZGUgdHJhbnNmb3JtZWQuXG5cbiAgKFNvLi4uIHdoeSBub3QganVzdCB1c2UgYW4gYXJyYXk/IFRoZSBiaWdnZXN0IHJlYXNvbiBpcyB0aGF0IGFuIGFycmF5IGNhbiBiZVxuICBhbnkgbGVuZ3RoLiBXaXRoIGEgYE1heWJlYCwgd2UncmUgY2FwdHVyaW5nIHRoZSBpZGVhIG9mIFwic29tZXRoaW5nIG9yXG4gIG5vdGhpbmdcIiByYXRoZXIgdGhhbiBcIjAgdG8gblwiIGl0ZW1zLiBBbmQgdGhpcyBsZXRzIHVzIGltcGxlbWVudCBhIHdob2xlIHNldFxuICBvZiAqb3RoZXIqIGludGVyZmFjZXMsIGxpa2UgdGhvc2UgaW4gdGhpcyBtb2R1bGUuKVxuXG4gICMjIyMgRXhhbXBsZXNcblxuICBgYGB0c1xuICBjb25zdCBsZW5ndGggPSAoczogc3RyaW5nKSA9PiBzLmxlbmd0aDtcblxuICBjb25zdCBqdXN0QVN0cmluZyA9IE1heWJlLmp1c3QoJ3N0cmluZycpO1xuICBjb25zdCBqdXN0VGhlU3RyaW5nTGVuZ3RoID0gbWFwKGxlbmd0aCwganVzdEFTdHJpbmcpO1xuICBjb25zb2xlLmxvZyhqdXN0VGhlU3RyaW5nTGVuZ3RoLnRvU3RyaW5nKCkpOyAvLyBKdXN0KDYpXG5cbiAgY29uc3Qgbm90QVN0cmluZyA9IE1heWJlLm5vdGhpbmc8c3RyaW5nPigpO1xuICBjb25zdCBub3RBU3RyaW5nTGVuZ3RoID0gbWFwKGxlbmd0aCwgbm90QVN0cmluZyk7XG4gIGNvbnNvbGUubG9nKG5vdEFTdHJpbmdMZW5ndGgudG9TdHJpbmcoKSk7IC8vIFwiTm90aGluZ1wiXG4gIGBgYFxuXG4gIEB0eXBlcGFyYW0gVCBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgQHR5cGVwYXJhbSBVIFRoZSB0eXBlIG9mIHRoZSB3cmFwcGVkIHZhbHVlIG9mIHRoZSByZXR1cm5lZCBgTWF5YmVgLlxuICBAcGFyYW0gbWFwRm4gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRoZSB2YWx1ZSB0byBpZiBgTWF5YmVgIGlzIGBKdXN0YC5cbiAgQHBhcmFtIG1heWJlIFRoZSBgTWF5YmVgIGluc3RhbmNlIHRvIG1hcCBvdmVyLlxuICBAcmV0dXJucyAgICAgQSBuZXcgYE1heWJlYCB3aXRoIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYG1hcEZuYCB0byB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgIGluIGEgYEp1c3RgLCBvciBgTm90aGluZ2AgaWYgYG1heWJlYCBpcyBgTm90aGluZ2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXA8VCwgVT4obWFwRm46ICh0OiBUKSA9PiBVKTogKG1heWJlOiBNYXliZTxUPikgPT4gTWF5YmU8VT47XG5leHBvcnQgZnVuY3Rpb24gbWFwPFQsIFU+KG1hcEZuOiAodDogVCkgPT4gVSwgbWF5YmU6IE1heWJlPFQ+KTogTWF5YmU8VT47XG5leHBvcnQgZnVuY3Rpb24gbWFwPFQsIFU+KFxuICBtYXBGbjogKHQ6IFQpID0+IFUsXG4gIG1heWJlPzogTWF5YmU8VD5cbik6IE1heWJlPFU+IHwgKChtYXliZTogTWF5YmU8VD4pID0+IE1heWJlPFU+KSB7XG4gIGNvbnN0IG9wID0gKG06IE1heWJlPFQ+KSA9PiAobS5pc0p1c3QoKSA/IGp1c3QobWFwRm4obS52YWx1ZSkpIDogbm90aGluZzxVPigpKTtcbiAgcmV0dXJuIGN1cnJ5MShvcCwgbWF5YmUpO1xufVxuXG4vKipcbiAgTWFwIG92ZXIgYSBgTWF5YmVgIGluc3RhbmNlIGFuZCBnZXQgb3V0IHRoZSB2YWx1ZSBpZiBgbWF5YmVgIGlzIGEgYEp1c3RgLCBvclxuICByZXR1cm4gYSBkZWZhdWx0IHZhbHVlIGlmIGBtYXliZWAgaXMgYSBgTm90aGluZ2AuXG5cbiAgIyMjIyBFeGFtcGxlc1xuXG4gIGBgYHRzXG4gIGNvbnN0IGxlbmd0aCA9IChzOiBzdHJpbmcpID0+IHMubGVuZ3RoO1xuXG4gIGNvbnN0IGp1c3RBU3RyaW5nID0gTWF5YmUuanVzdCgnc3RyaW5nJyk7XG4gIGNvbnN0IHRoZVN0cmluZ0xlbmd0aCA9IG1hcE9yKDAsIGxlbmd0aCwganVzdEFTdHJpbmcpO1xuICBjb25zb2xlLmxvZyh0aGVTdHJpbmdMZW5ndGgpOyAvLyA2XG5cbiAgY29uc3Qgbm90QVN0cmluZyA9IE1heWJlLm5vdGhpbmc8c3RyaW5nPigpO1xuICBjb25zdCBub3RBU3RyaW5nTGVuZ3RoID0gbWFwT3IoMCwgbGVuZ3RoLCBub3RBU3RyaW5nKVxuICBjb25zb2xlLmxvZyhub3RBU3RyaW5nTGVuZ3RoKTsgLy8gMFxuICBgYGBcblxuICBAdHlwZXBhcmFtIFQgVGhlIHR5cGUgb2YgdGhlIHdyYXBwZWQgdmFsdWUuXG4gIEB0eXBlcGFyYW0gVSBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZSBvZiB0aGUgcmV0dXJuZWQgYE1heWJlYC5cbiAgQHBhcmFtIG9yVSAgIFRoZSBkZWZhdWx0IHZhbHVlIHRvIHVzZSBpZiBgbWF5YmVgIGlzIGBOb3RoaW5nYFxuICBAcGFyYW0gbWFwRm4gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRoZSB2YWx1ZSB0byBpZiBgTWF5YmVgIGlzIGBKdXN0YFxuICBAcGFyYW0gbWF5YmUgVGhlIGBNYXliZWAgaW5zdGFuY2UgdG8gbWFwIG92ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBPcjxULCBVPihvclU6IFUsIG1hcEZuOiAodDogVCkgPT4gVSwgbWF5YmU6IE1heWJlPFQ+KTogVTtcbmV4cG9ydCBmdW5jdGlvbiBtYXBPcjxULCBVPihvclU6IFUsIG1hcEZuOiAodDogVCkgPT4gVSk6IChtYXliZTogTWF5YmU8VD4pID0+IFU7XG5leHBvcnQgZnVuY3Rpb24gbWFwT3I8VCwgVT4ob3JVOiBVKTogKG1hcEZuOiAodDogVCkgPT4gVSkgPT4gKG1heWJlOiBNYXliZTxUPikgPT4gVTtcbmV4cG9ydCBmdW5jdGlvbiBtYXBPcjxULCBVPihcbiAgb3JVOiBVLFxuICBtYXBGbj86ICh0OiBUKSA9PiBVLFxuICBtYXliZT86IE1heWJlPFQ+XG4pOiBVIHwgKChtYXliZTogTWF5YmU8VD4pID0+IFUpIHwgKChtYXBGbjogKHQ6IFQpID0+IFUpID0+IChtYXliZTogTWF5YmU8VD4pID0+IFUpIHtcbiAgZnVuY3Rpb24gZnVsbE9wKGZuOiAodDogVCkgPT4gVSwgbTogTWF5YmU8VD4pIHtcbiAgICByZXR1cm4gbS5pc0p1c3QoKSA/IGZuKG0udmFsdWUpIDogb3JVO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFydGlhbE9wKGZuOiAodDogVCkgPT4gVSk6IChtYXliZTogTWF5YmU8VD4pID0+IFU7XG4gIGZ1bmN0aW9uIHBhcnRpYWxPcChmbjogKHQ6IFQpID0+IFUsIGN1cnJpZWRNYXliZTogTWF5YmU8VD4pOiBVO1xuICBmdW5jdGlvbiBwYXJ0aWFsT3AoZm46ICh0OiBUKSA9PiBVLCBjdXJyaWVkTWF5YmU/OiBNYXliZTxUPik6IFUgfCAoKG1heWJlOiBNYXliZTxUPikgPT4gVSkge1xuICAgIHJldHVybiBjdXJyaWVkTWF5YmUgIT09IHVuZGVmaW5lZFxuICAgICAgPyBmdWxsT3AoZm4sIGN1cnJpZWRNYXliZSlcbiAgICAgIDogKGV4dHJhQ3VycmllZE1heWJlOiBNYXliZTxUPikgPT4gZnVsbE9wKGZuLCBleHRyYUN1cnJpZWRNYXliZSk7XG4gIH1cblxuICByZXR1cm4gbWFwRm4gPT09IHVuZGVmaW5lZFxuICAgID8gcGFydGlhbE9wXG4gICAgOiBtYXliZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/IHBhcnRpYWxPcChtYXBGbilcbiAgICAgIDogcGFydGlhbE9wKG1hcEZuLCBtYXliZSk7XG59XG5cbi8qKlxuICBNYXAgb3ZlciBhIGBNYXliZWAgaW5zdGFuY2UgYW5kIGdldCBvdXQgdGhlIHZhbHVlIGlmIGBtYXliZWAgaXMgYSBgSnVzdGAsXG4gIG9yIHVzZSBhIGZ1bmN0aW9uIHRvIGNvbnN0cnVjdCBhIGRlZmF1bHQgdmFsdWUgaWYgYG1heWJlYCBpcyBgTm90aGluZ2AuXG5cbiAgIyMjIyBFeGFtcGxlc1xuXG4gIGBgYHRzXG4gIGNvbnN0IGxlbmd0aCA9IChzOiBzdHJpbmcpID0+IHMubGVuZ3RoO1xuICBjb25zdCBnZXREZWZhdWx0ID0gKCkgPT4gMDtcblxuICBjb25zdCBqdXN0QVN0cmluZyA9IE1heWJlLmp1c3QoJ3N0cmluZycpO1xuICBjb25zdCB0aGVTdHJpbmdMZW5ndGggPSBtYXBPckVsc2UoZ2V0RGVmYXVsdCwgbGVuZ3RoLCBqdXN0QVN0cmluZyk7XG4gIGNvbnNvbGUubG9nKHRoZVN0cmluZ0xlbmd0aCk7IC8vIDZcblxuICBjb25zdCBub3RBU3RyaW5nID0gTWF5YmUubm90aGluZzxzdHJpbmc+KCk7XG4gIGNvbnN0IG5vdEFTdHJpbmdMZW5ndGggPSBtYXBPckVsc2UoZ2V0RGVmYXVsdCwgbGVuZ3RoLCBub3RBU3RyaW5nKVxuICBjb25zb2xlLmxvZyhub3RBU3RyaW5nTGVuZ3RoKTsgLy8gMFxuICBgYGBcblxuICBAdHlwZXBhcmFtIFQgICAgVGhlIHR5cGUgb2YgdGhlIHdyYXBwZWQgdmFsdWUuXG4gIEB0eXBlcGFyYW0gVSAgICBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZSBvZiB0aGUgcmV0dXJuZWQgYE1heWJlYC5cbiAgQHBhcmFtIG9yRWxzZUZuIFRoZSBmdW5jdGlvbiB0byBhcHBseSBpZiBgbWF5YmVgIGlzIGBOb3RoaW5nYC5cbiAgQHBhcmFtIG1hcEZuICAgIFRoZSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgd3JhcHBlZCB2YWx1ZSBpZiBgbWF5YmVgIGlzIGBKdXN0YFxuICBAcGFyYW0gbWF5YmUgICAgVGhlIGBNYXliZWAgaW5zdGFuY2UgdG8gbWFwIG92ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBPckVsc2U8VCwgVT4ob3JFbHNlRm46ICgpID0+IFUsIG1hcEZuOiAodDogVCkgPT4gVSwgbWF5YmU6IE1heWJlPFQ+KTogVTtcbmV4cG9ydCBmdW5jdGlvbiBtYXBPckVsc2U8VCwgVT4ob3JFbHNlRm46ICgpID0+IFUsIG1hcEZuOiAodDogVCkgPT4gVSk6IChtYXliZTogTWF5YmU8VD4pID0+IFU7XG5leHBvcnQgZnVuY3Rpb24gbWFwT3JFbHNlPFQsIFU+KG9yRWxzZUZuOiAoKSA9PiBVKTogKG1hcEZuOiAodDogVCkgPT4gVSkgPT4gKG1heWJlOiBNYXliZTxUPikgPT4gVTtcbmV4cG9ydCBmdW5jdGlvbiBtYXBPckVsc2U8VCwgVT4oXG4gIG9yRWxzZUZuOiAoKSA9PiBVLFxuICBtYXBGbj86ICh0OiBUKSA9PiBVLFxuICBtYXliZT86IE1heWJlPFQ+XG4pOiBVIHwgKChtYXliZTogTWF5YmU8VD4pID0+IFUpIHwgKChtYXBGbjogKHQ6IFQpID0+IFUpID0+IChtYXliZTogTWF5YmU8VD4pID0+IFUpIHtcbiAgZnVuY3Rpb24gZnVsbE9wKGZuOiAodDogVCkgPT4gVSwgbTogTWF5YmU8VD4pIHtcbiAgICByZXR1cm4gbS5pc0p1c3QoKSA/IGZuKG0udmFsdWUpIDogb3JFbHNlRm4oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnRpYWxPcChmbjogKHQ6IFQpID0+IFUpOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBVO1xuICBmdW5jdGlvbiBwYXJ0aWFsT3AoZm46ICh0OiBUKSA9PiBVLCBjdXJyaWVkTWF5YmU6IE1heWJlPFQ+KTogVTtcbiAgZnVuY3Rpb24gcGFydGlhbE9wKGZuOiAodDogVCkgPT4gVSwgY3VycmllZE1heWJlPzogTWF5YmU8VD4pOiBVIHwgKChtYXliZTogTWF5YmU8VD4pID0+IFUpIHtcbiAgICByZXR1cm4gY3VycmllZE1heWJlICE9PSB1bmRlZmluZWRcbiAgICAgID8gZnVsbE9wKGZuLCBjdXJyaWVkTWF5YmUpXG4gICAgICA6IChleHRyYUN1cnJpZWRNYXliZTogTWF5YmU8VD4pID0+IGZ1bGxPcChmbiwgZXh0cmFDdXJyaWVkTWF5YmUpO1xuICB9XG5cbiAgaWYgKG1hcEZuID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcGFydGlhbE9wO1xuICB9IGVsc2UgaWYgKG1heWJlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcGFydGlhbE9wKG1hcEZuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFydGlhbE9wKG1hcEZuLCBtYXliZSk7XG4gIH1cbn1cblxuLyoqXG4gIFlvdSBjYW4gdGhpbmsgb2YgdGhpcyBsaWtlIGEgc2hvcnQtY2lyY3VpdGluZyBsb2dpY2FsIFwiYW5kXCIgb3BlcmF0aW9uIG9uIGFcbiAgYE1heWJlYCB0eXBlLiBJZiBgbWF5YmVgIGlzIGBKdXN0YCwgdGhlbiB0aGUgcmVzdWx0IGlzIHRoZSBgYW5kTWF5YmVgLiBJZlxuICBgbWF5YmVgIGlzIGBOb3RoaW5nYCwgdGhlIHJlc3VsdCBpcyBgTm90aGluZ2AuXG5cbiAgVGhpcyBpcyB1c2VmdWwgd2hlbiB5b3UgaGF2ZSBhbm90aGVyIGBNYXliZWAgdmFsdWUgeW91IHdhbnQgdG8gcHJvdmlkZSBpZiBhbmRcbiAgKm9ubHkgaWYqIHlvdSBoYXZlIGEgYEp1c3RgIOKAkyB0aGF0IGlzLCB3aGVuIHlvdSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGlmIHlvdVxuICBgTm90aGluZ2AsIHdoYXRldmVyIGVsc2UgeW91J3JlIGhhbmRpbmcgYSBgTWF5YmVgIHRvICphbHNvKiBnZXRzIGEgYE5vdGhpbmdgLlxuXG4gIE5vdGljZSB0aGF0LCB1bmxpa2UgaW4gW2BtYXBgXSgjbWFwKSBvciBpdHMgdmFyaWFudHMsIHRoZSBvcmlnaW5hbCBgbWF5YmVgIGlzXG4gIG5vdCBpbnZvbHZlZCBpbiBjb25zdHJ1Y3RpbmcgdGhlIG5ldyBgTWF5YmVgLlxuXG4gICMjIyMgRXhhbXBsZXNcblxuICBgYGB0c1xuICBpbXBvcnQgTWF5YmUgZnJvbSAndHJ1ZS1teXRoL21heWJlJztcblxuICBjb25zdCBqdXN0QSA9IE1heWJlLmp1c3QoJ0EnKTtcbiAgY29uc3QganVzdEIgPSBNYXliZS5qdXN0KCdCJyk7XG4gIGNvbnN0IG5vdGhpbmc6IE1heWJlPG51bWJlcj4gPSBub3RoaW5nKCk7XG5cbiAgY29uc29sZS5sb2coTWF5YmUuYW5kKGp1c3RCLCBqdXN0QSkudG9TdHJpbmcoKSk7ICAvLyBKdXN0KEIpXG4gIGNvbnNvbGUubG9nKE1heWJlLmFuZChqdXN0Qiwgbm90aGluZykudG9TdHJpbmcoKSk7ICAvLyBOb3RoaW5nXG4gIGNvbnNvbGUubG9nKE1heWJlLmFuZChub3RoaW5nLCBqdXN0QSkudG9TdHJpbmcoKSk7ICAvLyBOb3RoaW5nXG4gIGNvbnNvbGUubG9nKE1heWJlLmFuZChub3RoaW5nLCBub3RoaW5nKS50b1N0cmluZygpKTsgIC8vIE5vdGhpbmdcbiAgYGBgXG5cbiAgQHR5cGVwYXJhbSBUICAgIFRoZSB0eXBlIG9mIHRoZSBpbml0aWFsIHdyYXBwZWQgdmFsdWUuXG4gIEB0eXBlcGFyYW0gVSAgICBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZSBvZiB0aGUgcmV0dXJuZWQgYE1heWJlYC5cbiAgQHBhcmFtIGFuZE1heWJlIFRoZSBgTWF5YmVgIGluc3RhbmNlIHRvIHJldHVybiBpZiBgbWF5YmVgIGlzIGBKdXN0YFxuICBAcGFyYW0gbWF5YmUgICAgVGhlIGBNYXliZWAgaW5zdGFuY2UgdG8gY2hlY2suXG4gIEByZXR1cm4gICAgICAgICBgTm90aGluZ2AgaWYgdGhlIG9yaWdpbmFsIGBtYXliZWAgaXMgYE5vdGhpbmdgLCBvciBgYW5kTWF5YmVgXG4gICAgICAgICAgICAgICAgICBpZiB0aGUgb3JpZ2luYWwgYG1heWJlYCBpcyBgSnVzdGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbmQ8VCwgVT4oYW5kTWF5YmU6IE1heWJlPFU+LCBtYXliZTogTWF5YmU8VD4pOiBNYXliZTxVPjtcbmV4cG9ydCBmdW5jdGlvbiBhbmQ8VCwgVT4oYW5kTWF5YmU6IE1heWJlPFU+KTogKG1heWJlOiBNYXliZTxUPikgPT4gTWF5YmU8VT47XG5leHBvcnQgZnVuY3Rpb24gYW5kPFQsIFU+KFxuICBhbmRNYXliZTogTWF5YmU8VT4sXG4gIG1heWJlPzogTWF5YmU8VD5cbik6IE1heWJlPFU+IHwgKChtYXliZTogTWF5YmU8VD4pID0+IE1heWJlPFU+KSB7XG4gIGNvbnN0IG9wID0gKG06IE1heWJlPFQ+KSA9PiAobS5pc0p1c3QoKSA/IGFuZE1heWJlIDogbm90aGluZzxVPigpKTtcbiAgcmV0dXJuIGN1cnJ5MShvcCwgbWF5YmUpO1xufVxuXG4vKipcbiAgQXBwbHkgYSBmdW5jdGlvbiB0byB0aGUgd3JhcHBlZCB2YWx1ZSBpZiBgSnVzdGAgYW5kIHJldHVybiBhIG5ldyBgSnVzdGBcbiAgY29udGFpbmluZyB0aGUgcmVzdWx0aW5nIHZhbHVlOyBvciByZXR1cm4gYE5vdGhpbmdgIGlmIGBOb3RoaW5nYC5cblxuICBUaGlzIGRpZmZlcnMgZnJvbSBgbWFwYCBpbiB0aGF0IGB0aGVuRm5gIHJldHVybnMgYW5vdGhlciBgTWF5YmVgLiBZb3UgY2FuIHVzZVxuICBgYW5kVGhlbmAgdG8gY29tYmluZSB0d28gZnVuY3Rpb25zIHdoaWNoICpib3RoKiBjcmVhdGUgYSBgTWF5YmVgIGZyb20gYW5cbiAgdW53cmFwcGVkIHR5cGUuXG5cbiAgWW91IG1heSBmaW5kIHRoZSBgLnRoZW5gIG1ldGhvZCBvbiBhbiBFUzYgYFByb21pc2VgIGhlbHBmdWwgZm9yIGI6XG4gIGlmIHlvdSBoYXZlIGEgYFByb21pc2VgLCB5b3UgY2FuIHBhc3MgaXRzIGB0aGVuYCBtZXRob2QgYSBjYWxsYmFjayB3aGljaFxuICByZXR1cm5zIGFub3RoZXIgYFByb21pc2VgLCBhbmQgdGhlIHJlc3VsdCB3aWxsIG5vdCBiZSBhICpuZXN0ZWQqIHByb21pc2UsIGJ1dFxuICBhIHNpbmdsZSBgUHJvbWlzZWAuIFRoZSBkaWZmZXJlbmNlIGlzIHRoYXQgYFByb21pc2UjdGhlbmAgdW53cmFwcyAqYWxsKlxuICBsYXllcnMgdG8gb25seSBldmVyIHJldHVybiBhIHNpbmdsZSBgUHJvbWlzZWAgdmFsdWUsIHdoZXJlYXMgYE1heWJlLmFuZFRoZW5gXG4gIHdpbGwgbm90IHVud3JhcCBuZXN0ZWQgYE1heWJlYHMuXG5cbiAgVGhpcyBpcyBhbHNvIGNvbW1vbmx5IGtub3duIGFzIChhbmQgdGhlcmVmb3JlIGFsaWFzZWQgYXMpIFtgZmxhdE1hcGBdIG9yXG4gIFtgY2hhaW5gXS4gSXQgaXMgc29tZXRpbWVzIGFsc28ga25vd24gYXMgYGJpbmRgLCBidXQgKm5vdCogYWxpYXNlZCBhcyBzdWNoXG4gIGJlY2F1c2UgW2BiaW5kYCBhbHJlYWR5IG1lYW5zIHNvbWV0aGluZyBpbiBKYXZhU2NyaXB0XVtiaW5kXS5cblxuICBbYGZsYXRNYXBgXTogI2ZsYXRtYXBcbiAgW2BjaGFpbmBdOiAjY2hhaW5cbiAgW2JpbmRdOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kXG5cbiAgIyMjIyBFeGFtcGxlXG5cbiAgKFRoaXMgaXMgYSBzb21ld2hhdCBjb250cml2ZWQgZXhhbXBsZSwgYnV0IGl0IHNlcnZlcyB0byBzaG93IHRoZSB3YXkgdGhlXG4gIGZ1bmN0aW9uIGJlaGF2ZXMuKVxuXG4gIGBgYHRzXG4gIGltcG9ydCBNYXliZSBmcm9tICd0cnVlLW15dGgvbWF5YmUnO1xuXG4gIC8vIHN0cmluZyAtPiBNYXliZTxudW1iZXI+XG4gIGNvbnN0IHRvTWF5YmVMZW5ndGggPSAoczogc3RyaW5nKTogTWF5YmU8bnVtYmVyPiA9PiBNYXliZS5vZihzLmxlbmd0aCk7XG5cbiAgLy8gTWF5YmU8c3RyaW5nPlxuICBjb25zdCBhTWF5YmVTdHJpbmcgPSBNYXliZS5vZignSGVsbG8sIHRoZXJlIScpO1xuXG4gIC8vIE1heWJlPG51bWJlcj5cbiAgY29uc3QgcmVzdWx0aW5nTGVuZ3RoID0gTWF5YmUuYW5kVGhlbih0b01heWJlTGVuZ3RoLCBhTWF5YmVTdHJpbmcpO1xuICBjb25zb2xlLmxvZyhNYXliZS50b1N0cmluZyhyZXN1bHRpbmdMZW5ndGgpKTsgLy8gMTNcbiAgYGBgXG5cbiAgTm90ZSB0aGF0IHRoZSByZXN1bHQgaXMgbm90IGAoSnVzdCgxMykpYCwgYnV0IGAxM2AhXG5cbiAgQHR5cGVwYXJhbSBUICBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgQHR5cGVwYXJhbSBUICBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZSBpbiB0aGUgcmVzdWx0aW5nIGBNYXliZWAuXG4gIEBwYXJhbSB0aGVuRm4gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIHRoZSB3cmFwcGVkIGBUYCBpZiBgbWF5YmVgIGlzIGBKdXN0YC5cbiAgQHBhcmFtIG1heWJlICBUaGUgYE1heWJlYCB0byBldmFsdWF0ZSBhbmQgcG9zc2libHkgYXBwbHkgYSBmdW5jdGlvbiB0byB0aGVcbiAgICAgICAgICAgICAgICBjb250ZW50cyBvZi5cbiAgQHJldHVybnMgICAgICBUaGUgcmVzdWx0IG9mIHRoZSBgdGhlbkZuYCAoYSBuZXcgYE1heWJlYCkgaWYgYG1heWJlYCBpcyBhXG4gICAgICAgICAgICAgICAgYEp1c3RgLCBvdGhlcndpc2UgYE5vdGhpbmdgIGlmIGBtYXliZWAgaXMgYSBgTm90aGluZ2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbmRUaGVuPFQsIFU+KHRoZW5GbjogKHQ6IFQpID0+IE1heWJlPFU+LCBtYXliZTogTWF5YmU8VD4pOiBNYXliZTxVPjtcbmV4cG9ydCBmdW5jdGlvbiBhbmRUaGVuPFQsIFU+KHRoZW5GbjogKHQ6IFQpID0+IE1heWJlPFU+KTogKG1heWJlOiBNYXliZTxUPikgPT4gTWF5YmU8VT47XG5leHBvcnQgZnVuY3Rpb24gYW5kVGhlbjxULCBVPihcbiAgdGhlbkZuOiAodDogVCkgPT4gTWF5YmU8VT4sXG4gIG1heWJlPzogTWF5YmU8VD5cbik6IE1heWJlPFU+IHwgKChtYXliZTogTWF5YmU8VD4pID0+IE1heWJlPFU+KSB7XG4gIGNvbnN0IG9wID0gKG06IE1heWJlPFQ+KSA9PiAobS5pc0p1c3QoKSA/IHRoZW5GbihtLnZhbHVlKSA6IG5vdGhpbmc8VT4oKSk7XG4gIHJldHVybiBtYXliZSAhPT0gdW5kZWZpbmVkID8gb3AobWF5YmUpIDogb3A7XG59XG5cbi8qKiBBbGlhcyBmb3IgW2BhbmRUaGVuYF0oI2FuZHRoZW4pLiAqL1xuZXhwb3J0IGNvbnN0IGNoYWluID0gYW5kVGhlbjtcblxuLyoqIEFsaWFzIGZvciBbYGFuZFRoZW5gXSgjYW5kdGhlbikuICovXG5leHBvcnQgY29uc3QgZmxhdE1hcCA9IGFuZFRoZW47XG5cbi8qKlxuICBQcm92aWRlIGEgZmFsbGJhY2sgZm9yIGEgZ2l2ZW4gYE1heWJlYC4gQmVoYXZlcyBsaWtlIGEgbG9naWNhbCBgb3JgOiBpZiB0aGVcbiAgYG1heWJlYCB2YWx1ZSBpcyBhIGBKdXN0YCwgcmV0dXJucyB0aGF0IGBtYXliZWA7IG90aGVyd2lzZSwgcmV0dXJucyB0aGVcbiAgYGRlZmF1bHRNYXliZWAgdmFsdWUuXG5cbiAgVGhpcyBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCBzb21ldGhpbmcgd2hpY2ggdGFrZXMgYVxuICBgTWF5YmVgIGFsd2F5cyBlbmRzIHVwIGdldHRpbmcgYSBgSnVzdGAgdmFyaWFudCwgYnkgc3VwcGx5aW5nIGEgZGVmYXVsdCB2YWx1ZVxuICBmb3IgdGhlIGNhc2UgdGhhdCB5b3UgY3VycmVudGx5IGhhdmUgYSBub3RoaW5nLlxuXG4gIGBgYHRzXG4gIGltcG9ydCBNYXliZSBmcm9tICd0cnVlLXV0aWxzL21heWJlJztcblxuICBjb25zdCBqdXN0QSA9IE1heWJlLmp1c3QoXCJhXCIpO1xuICBjb25zdCBqdXN0QiA9IE1heWJlLmp1c3QoXCJiXCIpO1xuICBjb25zdCBhTm90aGluZzogTWF5YmU8c3RyaW5nPiA9IG5vdGhpbmcoKTtcblxuICBjb25zb2xlLmxvZyhNYXliZS5vcihqdXN0QiwganVzdEEpLnRvU3RyaW5nKCkpOyAgLy8gSnVzdChBKVxuICBjb25zb2xlLmxvZyhNYXliZS5vcihhTm90aGluZywganVzdEEpLnRvU3RyaW5nKCkpOyAgLy8gSnVzdChBKVxuICBjb25zb2xlLmxvZyhNYXliZS5vcihqdXN0QiwgYU5vdGhpbmcpLnRvU3RyaW5nKCkpOyAgLy8gSnVzdChCKVxuICBjb25zb2xlLmxvZyhNYXliZS5vcihhTm90aGluZywgYU5vdGhpbmcpLnRvU3RyaW5nKCkpOyAgLy8gTm90aGluZ1xuICBgYGBcblxuICBAdHlwZXBhcmFtIFQgICAgICAgIFRoZSB0eXBlIG9mIHRoZSB3cmFwcGVkIHZhbHVlLlxuICBAcGFyYW0gZGVmYXVsdE1heWJlIFRoZSBgTWF5YmVgIHRvIHVzZSBpZiBgbWF5YmVgIGlzIGEgYE5vdGhpbmdgLlxuICBAcGFyYW0gbWF5YmUgICAgICAgIFRoZSBgTWF5YmVgIGluc3RhbmNlIHRvIGV2YWx1YXRlLlxuICBAcmV0dXJucyAgICAgICAgICAgIGBtYXliZWAgaWYgaXQgaXMgYSBgSnVzdGAsIG90aGVyd2lzZSBgZGVmYXVsdE1heWJlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9yPFQ+KGRlZmF1bHRNYXliZTogTWF5YmU8VD4sIG1heWJlOiBNYXliZTxUPik6IE1heWJlPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIG9yPFQ+KGRlZmF1bHRNYXliZTogTWF5YmU8VD4pOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBNYXliZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiBvcjxUPihcbiAgZGVmYXVsdE1heWJlOiBNYXliZTxUPixcbiAgbWF5YmU/OiBNYXliZTxUPlxuKTogTWF5YmU8VD4gfCAoKG1heWJlOiBNYXliZTxUPikgPT4gTWF5YmU8VD4pIHtcbiAgY29uc3Qgb3AgPSAobTogTWF5YmU8VD4pID0+IChtLmlzSnVzdCgpID8gbSA6IGRlZmF1bHRNYXliZSk7XG4gIHJldHVybiBtYXliZSAhPT0gdW5kZWZpbmVkID8gb3AobWF5YmUpIDogb3A7XG59XG5cbi8qKlxuICBMaWtlIGBvcmAsIGJ1dCB1c2luZyBhIGZ1bmN0aW9uIHRvIGNvbnN0cnVjdCB0aGUgYWx0ZXJuYXRpdmUgYE1heWJlYC5cblxuICBTb21ldGltZXMgeW91IG5lZWQgdG8gcGVyZm9ybSBhbiBvcGVyYXRpb24gdXNpbmcgb3RoZXIgZGF0YSBpbiB0aGVcbiAgZW52aXJvbm1lbnQgdG8gY29uc3RydWN0IHRoZSBmYWxsYmFjayB2YWx1ZS4gSW4gdGhlc2Ugc2l0dWF0aW9ucywgeW91IGNhblxuICBwYXNzIGEgZnVuY3Rpb24gKHdoaWNoIG1heSBiZSBhIGNsb3N1cmUpIGFzIHRoZSBgZWxzZUZuYCB0byBnZW5lcmF0ZSB0aGVcbiAgZmFsbGJhY2sgYE1heWJlPFQ+YC5cblxuICBVc2VmdWwgZm9yIHRyYW5zZm9ybWluZyBlbXB0eSBzY2VuYXJpb3MgYmFzZWQgb24gdmFsdWVzIGluIGNvbnRleHQuXG5cbiAgQHR5cGVwYXJhbSBUICBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgQHBhcmFtIGVsc2VGbiBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgaWYgYG1heWJlYCBpcyBgTm90aGluZ2BcbiAgQHBhcmFtIG1heWJlICBUaGUgYG1heWJlYCB0byB1c2UgaWYgaXQgaXMgYEp1c3RgLlxuICBAcmV0dXJucyAgICAgIFRoZSBgbWF5YmVgIGlmIGl0IGlzIGBKdXN0YCwgb3IgdGhlIGBNYXliZWAgcmV0dXJuZWQgYnlcbiAgICAgICAgICAgICAgICBgZWxzZUZuYCBpZiB0aGUgYG1heWJlYCBpcyBgTm90aGluZ2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvckVsc2U8VD4oZWxzZUZuOiAoKSA9PiBNYXliZTxUPiwgbWF5YmU6IE1heWJlPFQ+KTogTWF5YmU8VD47XG5leHBvcnQgZnVuY3Rpb24gb3JFbHNlPFQ+KGVsc2VGbjogKCkgPT4gTWF5YmU8VD4pOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBNYXliZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiBvckVsc2U8VD4oXG4gIGVsc2VGbjogKCkgPT4gTWF5YmU8VD4sXG4gIG1heWJlPzogTWF5YmU8VD5cbik6IE1heWJlPFQ+IHwgKChtYXliZTogTWF5YmU8VD4pID0+IE1heWJlPFQ+KSB7XG4gIGNvbnN0IG9wID0gKG06IE1heWJlPFQ+KSA9PiAobS5pc0p1c3QoKSA/IG0gOiBlbHNlRm4oKSk7XG4gIHJldHVybiBjdXJyeTEob3AsIG1heWJlKTtcbn1cblxuLyoqXG4gIEdldCB0aGUgdmFsdWUgb3V0IG9mIHRoZSBgTWF5YmVgLlxuXG4gIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgYSBgSnVzdGAsIGJ1dCAqKnRocm93cyBpZiB0aGUgYE1heWJlYCBpcyBgTm90aGluZ2AqKi5cbiAgUHJlZmVyIHRvIHVzZSBbYHVud3JhcE9yYF0oI3Vud3JhcG9yKSBvciBbYHVud3JhcE9yRWxzZWBdKCN1bndyYXBvcmVsc2UpLlxuXG4gIEB0eXBlcGFyYW0gVCBUaGUgdHlwZSBvZiB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgQHBhcmFtIG1heWJlIFRoZSB2YWx1ZSB0byB1bndyYXBcbiAgQHJldHVybnMgICAgIFRoZSB1bndyYXBwZWQgdmFsdWUgaWYgdGhlIGBNYXliZWAgaW5zdGFuY2UgaXMgYEp1c3RgLlxuICBAdGhyb3dzICAgICAgSWYgdGhlIGBtYXliZWAgaXMgYE5vdGhpbmdgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5zYWZlbHlVbndyYXA8VD4obWF5YmU6IE1heWJlPFQ+KTogVCB7XG4gIHJldHVybiBtYXliZS51bnNhZmVseVVud3JhcCgpO1xufVxuXG4vKiogQWxpYXMgZm9yIFtgdW5zYWZlbHlVbndyYXBgXSgjdW5zYWZlbHl1bndyYXApICovXG5leHBvcnQgY29uc3QgdW5zYWZlbHlHZXQgPSB1bnNhZmVseVVud3JhcDtcblxuLyoqIEFsaWFzIGZvciBbYHVuc2FmZWx5VW53cmFwYF0oI3Vuc2FmZWx5dW53cmFwKSAqL1xuZXhwb3J0IGNvbnN0IHVuc2FmZUdldCA9IHVuc2FmZWx5VW53cmFwO1xuXG4vKipcbiAgU2FmZWx5IGdldCB0aGUgdmFsdWUgb3V0IG9mIGEgYE1heWJlYC5cblxuICBSZXR1cm5zIHRoZSBjb250ZW50IG9mIGEgYEp1c3RgIG9yIGBkZWZhdWx0VmFsdWVgIGlmIGBOb3RoaW5nYC4gVGhpcyBpcyB0aGVcbiAgcmVjb21tZW5kZWQgd2F5IHRvIGdldCBhIHZhbHVlIG91dCBvZiBhIGBNYXliZWAgbW9zdCBvZiB0aGUgdGltZS5cblxuICBgYGB0c1xuICBpbXBvcnQgTWF5YmUgZnJvbSAndHJ1ZS1teXRoL21heWJlJztcblxuICBjb25zdCBub3RBU3RyaW5nID0gTWF5YmUubm90aGluZzxzdHJpbmc+KCk7XG4gIGNvbnN0IGlzQVN0cmluZyA9IE1heWJlLmp1c3QoJ2xvb2sgbWEhIHNvbWUgY2hhcmFjdGVycyEnKTtcblxuICBjb25zb2xlLmxvZyhNYXliZS51bndyYXBPcignPGVtcHR5PicsIG5vdEFTdHJpbmcpKTsgIC8vIFwiPGVtcHR5PlwiXG4gIGNvbnNvbGUubG9nKE1heWJlLnVud3JhcE9yKCc8ZW1wdHk+JywgaXNBU3RyaW5nKSk7ICAvLyBcImxvb2sgbWEhIHNvbWUgY2hhcmFjdGVycyFcIlxuICBgYGBcblxuICBAdHlwZXBhcmFtIFQgICAgICAgIFRoZSB0eXBlIG9mIHRoZSB3cmFwcGVkIHZhbHVlLlxuICBAcGFyYW0gZGVmYXVsdFZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgYG1heWJlYCBpcyBhIGBOb3RoaW5nYC5cbiAgQHBhcmFtIG1heWJlICAgICAgICBUaGUgYE1heWJlYCBpbnN0YW5jZSB0byB1bndyYXAgaWYgaXQgaXMgYSBgSnVzdGAuXG4gIEByZXR1cm5zICAgICAgICAgICAgVGhlIGNvbnRlbnQgb2YgYG1heWJlYCBpZiBpdCBpcyBhIGBKdXN0YCwgb3RoZXJ3aXNlXG4gICAgICAgICAgICAgICAgICAgICAgYGRlZmF1bHRWYWx1ZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBPcjxUPihkZWZhdWx0VmFsdWU6IFQsIG1heWJlOiBNYXliZTxUPik6IFQ7XG5leHBvcnQgZnVuY3Rpb24gdW53cmFwT3I8VD4oZGVmYXVsdFZhbHVlOiBUKTogKG1heWJlOiBNYXliZTxUPikgPT4gVDtcbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBPcjxUPihkZWZhdWx0VmFsdWU6IFQsIG1heWJlPzogTWF5YmU8VD4pIHtcbiAgY29uc3Qgb3AgPSAobTogTWF5YmU8VD4pID0+IChtLmlzSnVzdCgpID8gbS52YWx1ZSA6IGRlZmF1bHRWYWx1ZSk7XG4gIHJldHVybiBjdXJyeTEob3AsIG1heWJlKTtcbn1cblxuLyoqIEFsaWFzIGZvciBbYHVud3JhcE9yYF0oI3Vud3JhcG9yKSAqL1xuZXhwb3J0IGNvbnN0IGdldE9yID0gdW53cmFwT3I7XG5cbi8qKlxuICBTYWZlbHkgZ2V0IHRoZSB2YWx1ZSBvdXQgb2YgYSBbYE1heWJlYF0oI21heWJlKSBieSByZXR1cm5pbmcgdGhlIHdyYXBwZWRcbiAgdmFsdWUgaWYgaXQgaXMgYEp1c3RgLCBvciBieSBhcHBseWluZyBgb3JFbHNlRm5gIGlmIGl0IGlzIGBOb3RoaW5nYC5cblxuICBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvICpnZW5lcmF0ZSogYSB2YWx1ZSAoZS5nLiBieSB1c2luZyBjdXJyZW50XG4gIHZhbHVlcyBpbiB0aGUgZW52aXJvbm1lbnQg4oCTIHdoZXRoZXIgcHJlbG9hZGVkIG9yIGJ5IGxvY2FsIGNsb3N1cmUpIGluc3RlYWQgb2ZcbiAgaGF2aW5nIGEgc2luZ2xlIGRlZmF1bHQgdmFsdWUgYXZhaWxhYmxlIChhcyBpbiBbYHVud3JhcE9yYF0oI3Vud3JhcG9yKSkuXG5cbiAgYGBgdHNcbiAgaW1wb3J0IE1heWJlIGZyb20gJ3RydWUtbXl0aC9tYXliZSc7XG5cbiAgLy8gWW91IGNhbiBpbWFnaW5lIHRoYXQgc29tZU90aGVyVmFsdWUgbWlnaHQgYmUgZHluYW1pYy5cbiAgY29uc3Qgc29tZU90aGVyVmFsdWUgPSA5OTtcbiAgY29uc3QgaGFuZGxlTm90aGluZyA9ICgpID0+IHNvbWVPdGhlclZhbHVlO1xuXG4gIGNvbnN0IGFKdXN0ID0gTWF5YmUuanVzdCg0Mik7XG4gIGNvbnNvbGUubG9nKE1heWJlLnVud3JhcE9yRWxzZShoYW5kbGVOb3RoaW5nLCBhSnVzdCkpOyAgLy8gNDJcblxuICBjb25zdCBhTm90aGluZyA9IG5vdGhpbmc8bnVtYmVyPigpO1xuICBjb25zb2xlLmxvZyhNYXliZS51bndyYXBPckVsc2UoaGFuZGxlTm90aGluZywgYU5vdGhpbmcpKTsgLy8gOTlcbiAgYGBgXG5cbiAgQHR5cGVwYXJhbSBUICBUaGUgd3JhcHBlZCB2YWx1ZS5cbiAgQHBhcmFtIG9yRWxzZUZuIEEgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSBhIHZhbGlkIHZhbHVlIGlmIGBtYXliZWAgaXMgYVxuICAgICAgICAgICAgICAgICAgYE5vdGhpbmdgLlxuICBAcGFyYW0gbWF5YmUgICAgVGhlIGBNYXliZWAgaW5zdGFuY2UgdG8gdW53cmFwIGlmIGl0IGlzIGEgYEp1c3RgXG4gIEByZXR1cm5zICAgICAgICBFaXRoZXIgdGhlIGNvbnRlbnQgb2YgYG1heWJlYCBvciB0aGUgdmFsdWUgcmV0dXJuZWQgZnJvbVxuICAgICAgICAgICAgICAgICAgYG9yRWxzZUZuYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcE9yRWxzZTxUPihvckVsc2VGbjogKCkgPT4gVCwgbWF5YmU6IE1heWJlPFQ+KTogVDtcbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBPckVsc2U8VD4ob3JFbHNlRm46ICgpID0+IFQpOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBUO1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcE9yRWxzZTxUPihvckVsc2VGbjogKCkgPT4gVCwgbWF5YmU/OiBNYXliZTxUPik6IFQgfCAoKG1heWJlOiBNYXliZTxUPikgPT4gVCkge1xuICBjb25zdCBvcCA9IChtOiBNYXliZTxUPikgPT4gKG0uaXNKdXN0KCkgPyBtLnZhbHVlIDogb3JFbHNlRm4oKSk7XG4gIHJldHVybiBjdXJyeTEob3AsIG1heWJlKTtcbn1cblxuLyoqIEFsaWFzIGZvciBbYHVud3JhcE9yRWxzZWBdKCN1bndyYXBvcmVsc2UpICovXG5leHBvcnQgY29uc3QgZ2V0T3JFbHNlID0gdW53cmFwT3JFbHNlO1xuXG4vKipcbiAgVHJhbnNmb3JtIHRoZSBbYE1heWJlYF0oI21heWJlKSBpbnRvIGFcbiAgW2BSZXN1bHRgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjcmVzdWx0KSwgdXNpbmcgdGhlIHdyYXBwZWQgdmFsdWUgYXMgdGhlXG4gIGBPa2AgdmFsdWUgaWYgYEp1c3RgOyBvdGhlcndpc2UgdXNpbmcgdGhlIHN1cHBsaWVkIGBlcnJvcmAgdmFsdWUgZm9yIGBFcnJgLlxuXG4gIEB0eXBlcGFyYW0gVCAgVGhlIHdyYXBwZWQgdmFsdWUuXG4gIEB0eXBlcGFyYW0gRSAgVGhlIGVycm9yIHR5cGUgdG8gaW4gdGhlIGBSZXN1bHRgLlxuICBAcGFyYW0gZXJyb3IgVGhlIGVycm9yIHZhbHVlIHRvIHVzZSBpZiB0aGUgYE1heWJlYCBpcyBgTm90aGluZ2AuXG4gIEBwYXJhbSBtYXliZSBUaGUgYE1heWJlYCBpbnN0YW5jZSB0byBjb252ZXJ0LlxuICBAcmV0dXJucyAgICAgQSBgUmVzdWx0YCBjb250YWluaW5nIHRoZSB2YWx1ZSB3cmFwcGVkIGluIGBtYXliZWAgaW4gYW4gYE9rYCxcbiAgICAgICAgICAgICAgIG9yIGBlcnJvcmAgaW4gYW4gYEVycmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b09rT3JFcnI8VCwgRT4oZXJyb3I6IEUsIG1heWJlOiBNYXliZTxUPik6IFJlc3VsdDxULCBFPjtcbmV4cG9ydCBmdW5jdGlvbiB0b09rT3JFcnI8VCwgRT4oZXJyb3I6IEUpOiAobWF5YmU6IE1heWJlPFQ+KSA9PiBSZXN1bHQ8VCwgRT47XG5leHBvcnQgZnVuY3Rpb24gdG9Pa09yRXJyPFQsIEU+KFxuICBlcnJvcjogRSxcbiAgbWF5YmU/OiBNYXliZTxUPlxuKTogUmVzdWx0PFQsIEU+IHwgKChtYXliZTogTWF5YmU8VD4pID0+IFJlc3VsdDxULCBFPikge1xuICBjb25zdCBvcCA9IChtOiBNYXliZTxUPikgPT4gKG0uaXNKdXN0KCkgPyBvazxULCBFPihtLnZhbHVlKSA6IGVycjxULCBFPihlcnJvcikpO1xuICByZXR1cm4gbWF5YmUgIT09IHVuZGVmaW5lZCA/IG9wKG1heWJlKSA6IG9wO1xufVxuXG4vKipcbiAgVHJhbnNmb3JtIHRoZSBbYE1heWJlYF0oI21heWJlKSBpbnRvIGFcbiAgW2BSZXN1bHRgXSguLi9tb2R1bGVzL19yZXN1bHRfLmh0bWwjcmVzdWx0KSwgdXNpbmcgdGhlIHdyYXBwZWQgdmFsdWUgYXMgdGhlXG4gIGBPa2AgdmFsdWUgaWYgYEp1c3RgOyBvdGhlcndpc2UgdXNpbmcgYGVsc2VGbmAgdG8gZ2VuZXJhdGUgYEVycmAuXG5cbiAgQHR5cGVwYXJhbSBUICBUaGUgd3JhcHBlZCB2YWx1ZS5cbiAgQHR5cGVwYXJhbSBFICBUaGUgZXJyb3IgdHlwZSB0byBpbiB0aGUgYFJlc3VsdGAuXG4gIEBwYXJhbSBlbHNlRm4gVGhlIGZ1bmN0aW9uIHdoaWNoIGdlbmVyYXRlcyBhbiBlcnJvciBvZiB0eXBlIGBFYC5cbiAgQHBhcmFtIG1heWJlICBUaGUgYE1heWJlYCBpbnN0YW5jZSB0byBjb252ZXJ0LlxuICBAcmV0dXJucyAgICAgQSBgUmVzdWx0YCBjb250YWluaW5nIHRoZSB2YWx1ZSB3cmFwcGVkIGluIGBtYXliZWAgaW4gYW4gYE9rYCxcbiAgICAgICAgICAgICAgIG9yIHRoZSB2YWx1ZSBnZW5lcmF0ZWQgYnkgYGVsc2VGbmAgaW4gYW4gYEVycmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b09rT3JFbHNlRXJyPFQsIEU+KGVsc2VGbjogKCkgPT4gRSwgbWF5YmU6IE1heWJlPFQ+KTogUmVzdWx0PFQsIEU+O1xuZXhwb3J0IGZ1bmN0aW9uIHRvT2tPckVsc2VFcnI8VCwgRT4oZWxzZUZuOiAoKSA9PiBFKTogKG1heWJlOiBNYXliZTxUPikgPT4gUmVzdWx0PFQsIEU+O1xuZXhwb3J0IGZ1bmN0aW9uIHRvT2tPckVsc2VFcnI8VCwgRT4oXG4gIGVsc2VGbjogKCkgPT4gRSxcbiAgbWF5YmU/OiBNYXliZTxUPlxuKTogUmVzdWx0PFQsIEU+IHwgKChtYXliZTogTWF5YmU8VD4pID0+IFJlc3VsdDxULCBFPikge1xuICBjb25zdCBvcCA9IChtOiBNYXliZTxUPikgPT4gKG0uaXNKdXN0KCkgPyBvazxULCBFPihtLnZhbHVlKSA6IGVycjxULCBFPihlbHNlRm4oKSkpO1xuICByZXR1cm4gY3VycnkxKG9wLCBtYXliZSk7XG59XG5cbi8qKlxuICBDb25zdHJ1Y3QgYSBgTWF5YmU8VD5gIGZyb20gYSBgUmVzdWx0PFQsIEU+YC5cblxuICBJZiB0aGUgYFJlc3VsdGAgaXMgYW4gYE9rYCwgd3JhcCBpdHMgdmFsdWUgaW4gYEp1c3RgLiBJZiB0aGUgYFJlc3VsdGAgaXMgYW5cbiAgYEVycmAsIHRocm93IGF3YXkgdGhlIHdyYXBwZWQgYEVgIGFuZCB0cmFuc2Zvcm0gdG8gYSBgTm90aGluZ2AuXG5cbiAgQHR5cGVwYXJhbSBUICBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgd3JhcHBlZCBpbiBhIGBSZXN1bHQuT2tgIGFuZCBpbiB0aGUgYEp1c3RgXG4gICAgICAgICAgICAgICAgb2YgdGhlIHJlc3VsdGluZyBgTWF5YmVgLlxuICBAdHlwZXBhcmFtIEUgIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB3cmFwcGVkIGluIGEgYFJlc3VsdC5FcnJgOyB0aHJvd24gYXdheSBpblxuICAgICAgICAgICAgICAgIHRoZSByZXN1bHRpbmcgYE1heWJlYC5cbiAgQHBhcmFtIHJlc3VsdCBUaGUgYFJlc3VsdGAgdG8gY29uc3RydWN0IGEgYE1heWJlYCBmcm9tLlxuICBAcmV0dXJucyAgICAgIGBKdXN0YCBpZiBgcmVzdWx0YCB3YXMgYE9rYCBvciBgTm90aGluZ2AgaWYgaXQgd2FzIGBFcnJgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJlc3VsdDxUPihyZXN1bHQ6IFJlc3VsdDxULCBhbnk+KTogTWF5YmU8VD4ge1xuICByZXR1cm4gcmVzdWx0LmlzT2soKSA/IGp1c3QocmVzdWx0LnZhbHVlKSA6IG5vdGhpbmc8VD4oKTtcbn1cblxuLyoqXG4gIENyZWF0ZSBhIGBTdHJpbmdgIHJlcHJlc2VudGF0aW9uIG9mIGEgYE1heWJlYCBpbnN0YW5jZS5cblxuICBBIGBKdXN0YCBpbnN0YW5jZSB3aWxsIGJlIHByaW50ZWQgYXMgYEp1c3QoPHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2YWx1ZT4pYCxcbiAgd2hlcmUgdGhlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2YWx1ZSBpcyBzaW1wbHkgdGhlIHZhbHVlJ3Mgb3duIGB0b1N0cmluZ2BcbiAgcmVwcmVzZW50YXRpb24uIEZvciBleGFtcGxlOlxuXG4gIHwgY2FsbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBvdXRwdXQgICAgICAgICAgICAgICAgICB8XG4gIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gIHwgYHRvU3RyaW5nKE1heWJlLm9mKDQyKSlgICAgICAgICAgICAgICAgfCBgSnVzdCg0MilgICAgICAgICAgICAgICB8XG4gIHwgYHRvU3RyaW5nKE1heWJlLm9mKFsxLCAyLCAzXSkpYCAgICAgICAgfCBgSnVzdCgxLDIsMylgICAgICAgICAgICB8XG4gIHwgYHRvU3RyaW5nKE1heWJlLm9mKHsgYW46ICdvYmplY3QnIH0pKWAgfCBgSnVzdChbb2JqZWN0IE9iamVjdF0pYCB8XG4gIHwgYHRvU3RyaW5nKE1heWJlLm5vdGhpbmcoKSlgICAgICAgICAgICAgfCBgTm90aGluZ2AgICAgICAgICAgICAgICB8XG5cbiAgQHR5cGVwYXJhbSBUIFRoZSB0eXBlIG9mIHRoZSB3cmFwcGVkIHZhbHVlOyBpdHMgb3duIGAudG9TdHJpbmdgIHdpbGwgYmUgdXNlZFxuICAgICAgICAgICAgICAgdG8gcHJpbnQgdGhlIGludGVyaW9yIGNvbnRlbnRzIG9mIHRoZSBgSnVzdGAgdmFyaWFudC5cbiAgQHBhcmFtIG1heWJlIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgc3RyaW5nLlxuICBAcmV0dXJucyAgICAgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYE1heWJlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nPFQ+KG1heWJlOiBNYXliZTxUPik6IHN0cmluZyB7XG4gIGNvbnN0IGJvZHkgPSBtYXliZS5pc0p1c3QoKSA/IGAoJHttYXliZS52YWx1ZS50b1N0cmluZygpfSlgIDogJyc7XG4gIHJldHVybiBgJHttYXliZS52YXJpYW50fSR7Ym9keX1gO1xufVxuXG4vKiogQSBsaWdodHdlaWdodCBvYmplY3QgZGVmaW5pbmcgaG93IHRvIGhhbmRsZSBlYWNoIHZhcmlhbnQgb2YgYSBNYXliZS4gKi9cbmV4cG9ydCB0eXBlIE1hdGNoZXI8VCwgQT4gPSB7XG4gIEp1c3Q6ICh2YWx1ZTogVCkgPT4gQTtcbiAgTm90aGluZzogKCkgPT4gQTtcbn07XG5cbi8qKlxuICBQZXJmb3JtcyB0aGUgc2FtZSBiYXNpYyBmdW5jdGlvbmFsaXR5IGFzIGBnZXRPckVsc2VgLCBidXQgaW5zdGVhZCBvZiBzaW1wbHlcbiAgdW53cmFwcGluZyB0aGUgdmFsdWUgaWYgaXQgaXMgYEp1c3RgIGFuZCBhcHBseWluZyBhIHZhbHVlIHRvIGdlbmVyYXRlIHRoZSBzYW1lXG4gIGRlZmF1bHQgdHlwZSBpZiBpdCBpcyBgTm90aGluZ2AsIGxldHMgeW91IHN1cHBseSBmdW5jdGlvbnMgd2hpY2ggbWF5IHRyYW5zZm9ybVxuICB0aGUgd3JhcHBlZCB0eXBlIGlmIGl0IGlzIGBKdXN0YCBvciBnZXQgYSBkZWZhdWx0IHZhbHVlIGZvciBgTm90aGluZ2AuXG5cbiAgVGhpcyBpcyBraW5kIG9mIGxpa2UgYSBwb29yIG1hbidzIHZlcnNpb24gb2YgcGF0dGVybiBtYXRjaGluZywgd2hpY2hcbiAgSmF2YVNjcmlwdCBjdXJyZW50bHkgbGFja3MuXG5cbiAgSW5zdGVhZCBvZiBjb2RlIGxpa2UgdGhpczpcblxuICBgYGB0c1xuICBpbXBvcnQgTWF5YmUgZnJvbSAndHJ1ZS1teXRoL21heWJlJztcblxuICBjb25zdCBsb2dWYWx1ZSA9IChtaWdodEJlQU51bWJlcjogTWF5YmU8bnVtYmVyPikgPT4ge1xuICAgIGNvbnN0IHZhbHVlVG9Mb2cgPSBNYXliZS5taWdodEJlQU51bWJlci5pc0p1c3QoKVxuICAgICAgPyBNYXliZS51bnNhZmVseVVud3JhcChtaWdodEJlQU51bWJlcikudG9TdHJpbmcoKVxuICAgICAgOiAnTm90aGluZyB0byBsb2cuJztcblxuICAgIGNvbnNvbGUubG9nKHZhbHVlVG9Mb2cpO1xuICB9O1xuICBgYGBcblxuICAuLi53ZSBjYW4gd3JpdGUgY29kZSBsaWtlIHRoaXM6XG5cbiAgYGBgdHNcbiAgaW1wb3J0IE1heWJlIGZyb20gJ3RydWUtbXl0aC9tYXliZSc7XG5cbiAgY29uc3QgbG9nVmFsdWUgPSAobWlnaHRCZUFOdW1iZXI6IE1heWJlPG51bWJlcj4pID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IE1heWJlLm1hdGNoKFxuICAgICAge1xuICAgICAgICBKdXN0OiBuID0+IG4udG9TdHJpbmcoKSxcbiAgICAgICAgTm90aGluZzogKCkgPT4gJ05vdGhpbmcgdG8gbG9nLicsXG4gICAgICB9LFxuICAgICAgbWlnaHRCZUFOdW1iZXJcbiAgICApO1xuXG4gICAgY29uc29sZS5sb2codmFsdWUpO1xuICB9O1xuICBgYGBcblxuICBUaGlzIGlzIHNsaWdodGx5IGxvbmdlciB0byB3cml0ZSwgYnV0IGNsZWFyZXI6IHRoZSBtb3JlIGNvbXBsZXggdGhlIHJlc3VsdGluZ1xuICBleHByZXNzaW9uLCB0aGUgaGFpcmVyIGl0IGlzIHRvIHVuZGVyc3RhbmQgdGhlIHRlcm5hcnkuIFRodXMsIHRoaXMgaXNcbiAgZXNwZWNpYWxseSBjb252ZW5pZW50IGZvciB0aW1lcyB3aGVuIHRoZXJlIGlzIGEgY29tcGxleCByZXN1bHQsIGUuZy4gd2hlblxuICByZW5kZXJpbmcgcGFydCBvZiBhIFJlYWN0IGNvbXBvbmVudCBpbmxpbmUgaW4gSlNYL1RTWC5cblxuICBAcGFyYW0gbWF0Y2hlciBBIGxpZ2h0d2VpZ2h0IG9iamVjdCBkZWZpbmluZyB3aGF0IHRvIGRvIGluIHRoZSBjYXNlIG9mIGVhY2hcbiAgICAgICAgICAgICAgICAgdmFyaWFudC5cbiAgQHBhcmFtIG1heWJlICAgVGhlIGBtYXliZWAgaW5zdGFuY2UgdG8gY2hlY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaDxULCBBPihtYXRjaGVyOiBNYXRjaGVyPFQsIEE+LCBtYXliZTogTWF5YmU8VD4pOiBBO1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoPFQsIEE+KG1hdGNoZXI6IE1hdGNoZXI8VCwgQT4pOiAobTogTWF5YmU8VD4pID0+IEE7XG5leHBvcnQgZnVuY3Rpb24gbWF0Y2g8VCwgQT4obWF0Y2hlcjogTWF0Y2hlcjxULCBBPiwgbWF5YmU/OiBNYXliZTxUPik6IEEgfCAoKG06IE1heWJlPFQ+KSA9PiBBKSB7XG4gIHJldHVybiBtYXliZSAhPT0gdW5kZWZpbmVkXG4gICAgPyBtYXBPckVsc2UobWF0Y2hlci5Ob3RoaW5nLCBtYXRjaGVyLkp1c3QsIG1heWJlKVxuICAgIDogKGN1cnJpZWRNYXliZTogTWF5YmU8VD4pID0+IG1hcE9yRWxzZShtYXRjaGVyLk5vdGhpbmcsIG1hdGNoZXIuSnVzdCwgY3VycmllZE1heWJlKTtcbn1cblxuLyoqIEFsaWFzIGZvciBbYG1hdGNoYF0oI21hdGNoKSAqL1xuZXhwb3J0IGNvbnN0IGNhdGEgPSBtYXRjaDtcblxuLyoqXG4gIEFsbG93cyBxdWljayB0cmlwbGUtZXF1YWwgZXF1YWxpdHkgY2hlY2sgYmV0d2VlbiB0aGUgdmFsdWVzIGluc2lkZSB0d28gYG1heWJlYHNcbiAgd2l0aG91dCBoYXZpbmcgdG8gdW53cmFwIHRoZW0gZmlyc3QuXG5cbiAgYGBgdHNcbiAgY29uc3QgYSA9IE1heWJlLm9mKDMpO1xuICBjb25zdCBiID0gTWF5YmUub2YoMyk7XG4gIGNvbnN0IGMgPSBNYXliZS5vZihudWxsKTtcbiAgY29uc3QgZCA9IE1heWJlLm5vdGhpbmcoKTtcblxuICBNYXliZS5lcXVhbHMoYSwgYik7IC8vIHRydWVcbiAgTWF5YmUuZXF1YWxzKGEsIGMpOyAvLyBmYWxzZVxuICBNYXliZS5lcXVhbHMoYywgZCk7IC8vIHRydWVcbiAgYGBgXG5cbiAgQHBhcmFtIG1iIEEgYG1heWJlYCB0byBjb21wYXJlIHRvLlxuICBAcGFyYW0gbWEgQSBgbWF5YmVgIGluc3RhbmNlIHRvIGNoZWNrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzPFQ+KG1iOiBNYXliZTxUPiwgbWE6IE1heWJlPFQ+KTogYm9vbGVhbjtcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHM8VD4obWI6IE1heWJlPFQ+KTogKG1hOiBNYXliZTxUPikgPT4gYm9vbGVhbjtcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHM8VD4obWI6IE1heWJlPFQ+LCBtYT86IE1heWJlPFQ+KTogYm9vbGVhbiB8ICgoYTogTWF5YmU8VD4pID0+IGJvb2xlYW4pIHtcbiAgcmV0dXJuIG1hICE9PSB1bmRlZmluZWRcbiAgICA/IG1hLm1hdGNoKHtcbiAgICAgICAgSnVzdDogYVZhbCA9PiBtYi5pc0p1c3QoKSAmJiBtYi51bnNhZmVseVVud3JhcCgpID09PSBhVmFsLFxuICAgICAgICBOb3RoaW5nOiAoKSA9PiBpc05vdGhpbmcobWIpLFxuICAgICAgfSlcbiAgICA6IChtYXliZUE6IE1heWJlPFQ+KSA9PlxuICAgICAgICBtYXliZUEubWF0Y2goe1xuICAgICAgICAgIE5vdGhpbmc6ICgpID0+IGlzTm90aGluZyhtYiksXG4gICAgICAgICAgSnVzdDogYVZhbCA9PiBtYi5pc0p1c3QoKSAmJiBtYi51bnNhZmVseVVud3JhcCgpID09PSBhVmFsLFxuICAgICAgICB9KTtcbn1cblxuLyoqXG4gIEFsbG93cyB5b3UgdG8gKmFwcGx5KiAodGh1cyBgYXBgKSBhIHZhbHVlIHRvIGEgZnVuY3Rpb24gd2l0aG91dCBoYXZpbmcgdG9cbiAgdGFrZSBlaXRoZXIgb3V0IG9mIHRoZSBjb250ZXh0IG9mIHRoZWlyIGBNYXliZWBzLiBUaGlzIGRvZXMgbWVhbiB0aGF0IHRoZVxuICB0cmFuc2Zvcm1pbmcgZnVuY3Rpb24gaXMgaXRzZWxmIHdpdGhpbiBhIGBNYXliZWAsIHdoaWNoIGNhbiBiZSBoYXJkIHRvIGdyb2tcbiAgYXQgZmlyc3QgYnV0IGxldHMgeW91IGRvIHNvbWUgdmVyeSBlbGVnYW50IHRoaW5ncy4gRm9yIGV4YW1wbGUsIGBhcGAgYWxsb3dzXG4gIHlvdSB0byB0aGlzOlxuXG4gIGBgYHRzXG4gIGltcG9ydCB7IGp1c3QsIG5vdGhpbmcgfSBmcm9tICd0cnVlLW15dGgvbWF5YmUnO1xuXG4gIGNvbnN0IG9uZSA9IGp1c3QoMSk7XG4gIGNvbnN0IGZpdmUgPSBqdXN0KDUpO1xuICBjb25zdCBub25lID0gbm90aGluZygpO1xuXG4gIGNvbnN0IGFkZCA9IChhOiBudW1iZXIpID0+IChiOiBudW1iZXIpID0+IGEgKyBiO1xuICBjb25zdCBtYXliZUFkZCA9IGp1c3QoYWRkKTtcblxuICBtYXliZUFkZC5hcChvbmUpLmFwKGZpdmUpOyAvLyBKdXN0KDYpXG4gIG1heWJlQWRkLmFwKG9uZSkuYXAobm9uZSk7IC8vIE5vdGhpbmdcbiAgbWF5YmVBZGQuYXAobm9uZSkuYXAoZml2ZSkgLy8gTm90aGluZ1xuICBgYGBcblxuICBXaXRob3V0IGBNYXliZS5hcGAsIHlvdSdkIG5lZWQgdG8gZG8gc29tZXRoaW5nIGxpa2UgYSBuZXN0ZWQgYE1heWJlLm1hdGNoYDpcblxuICBgYGB0c1xuICBpbXBvcnQgeyBqdXN0LCBub3RoaW5nIH0gZnJvbSAndHJ1ZS1teXRoL21heWJlJztcblxuICBjb25zdCBvbmUgPSBqdXN0KDEpO1xuICBjb25zdCBmaXZlID0ganVzdCg1KTtcbiAgY29uc3Qgbm9uZSA9IG5vdGhpbmcoKTtcblxuICBvbmUubWF0Y2goe1xuICAgIEp1c3Q6IG4gPT4gZml2ZS5tYXRjaCh7XG4gICAgICBKdXN0OiBvID0+IGp1c3QobiArIG8pLFxuICAgICAgTm90aGluZzogKCkgPT4gbm90aGluZygpLFxuICAgIH0pLFxuICAgIE5vdGhpbmc6ICgpICA9PiBub3RoaW5nKCksXG4gIH0pOyAvLyBKdXN0KDYpXG5cbiAgb25lLm1hdGNoKHtcbiAgICBKdXN0OiBuID0+IG5vbmUubWF0Y2goe1xuICAgICAgSnVzdDogbyA9PiBqdXN0KG4gKyBvKSxcbiAgICAgIE5vdGhpbmc6ICgpID0+IG5vdGhpbmcoKSxcbiAgICB9KSxcbiAgICBOb3RoaW5nOiAoKSAgPT4gbm90aGluZygpLFxuICB9KTsgLy8gTm90aGluZ1xuXG4gIG5vbmUubWF0Y2goe1xuICAgIEp1c3Q6IG4gPT4gZml2ZS5tYXRjaCh7XG4gICAgICBKdXN0OiBvID0+IGp1c3QobiArIG8pLFxuICAgICAgTm90aGluZzogKCkgPT4gbm90aGluZygpLFxuICAgIH0pLFxuICAgIE5vdGhpbmc6ICgpICA9PiBub3RoaW5nKCksXG4gIH0pOyAvLyBOb3RoaW5nXG4gIGBgYFxuXG4gIEFuZCB0aGlzIGtpbmQgb2YgdGhpbmcgY29tZXMgdXAgcXVpdGUgb2Z0ZW4gb25jZSB5b3UncmUgdXNpbmcgYE1heWJlYCB0b1xuICBoYW5kbGUgb3B0aW9uYWxpdHkgdGhyb3VnaG91dCB5b3VyIGFwcGxpY2F0aW9uLlxuXG4gIEZvciBhbm90aGVyIGV4YW1wbGUsIGltYWdpbmUgeW91IG5lZWQgdG8gY29tcGFyZSB0aGUgZXF1YWxpdHkgb2YgdHdvXG4gIEltbXV0YWJsZUpTIGRhdGEgc3RydWN0dXJlcywgd2hlcmUgYSBgPT09YCBjb21wYXJpc29uIHdvbid0IHdvcmsuIFdpdGggYGFwYCxcbiAgdGhhdCdzIGFzIHNpbXBsZSBhcyB0aGlzOlxuXG4gIGBgYHRzXG4gIGltcG9ydCBNYXliZSBmcm9tICd0cnVlLW15dGgvbWF5YmUnO1xuICBpbXBvcnQgSW1tdXRhYmxlIGZyb20gJ2ltbXV0YWJsZSc7XG4gIGltcG9ydCB7IGN1cnJ5IH0gZnJvbSAnbG9kYXNoJ1xuXG4gIGNvbnN0IGlzID0gY3VycnkoSW1tdXRhYmxlLmlzKTtcblxuICBjb25zdCB4ID0gTWF5YmUub2YoSW1tdXRhYmxlLlNldC5vZigxLCAyLCAzKSk7XG4gIGNvbnN0IHkgPSBNYXliZS5vZihJbW11dGFibGUuU2V0Lm9mKDIsIDMsIDQpKTtcblxuICBNYXliZS5vZihpcykuYXAoeCkuYXAoeSk7IC8vIEp1c3QoZmFsc2UpXG4gIGBgYFxuXG4gIFdpdGhvdXQgYGFwYCwgd2UncmUgYmFjayB0byB0aGF0IGduYXJseSBuZXN0ZWQgYG1hdGNoYDpcblxuICBgYGB0c1xuICAgKiBpbXBvcnQgTWF5YmUsIHsganVzdCwgbm90aGluZyB9IGZyb20gJ3RydWUtbXl0aC9tYXliZSc7XG4gIGltcG9ydCBJbW11dGFibGUgZnJvbSAnaW1tdXRhYmxlJztcbiAgaW1wb3J0IHsgY3VycnkgfSBmcm9tICdsb2Rhc2gnXG5cbiAgY29uc3QgaXMgPSBjdXJyeShJbW11dGFibGUuaXMpO1xuXG4gIGNvbnN0IHggPSBNYXliZS5vZihJbW11dGFibGUuU2V0Lm9mKDEsIDIsIDMpKTtcbiAgY29uc3QgeSA9IE1heWJlLm9mKEltbXV0YWJsZS5TZXQub2YoMiwgMywgNCkpO1xuXG4gIHgubWF0Y2goe1xuICAgIEp1c3Q6IGlYID0+IHkubWF0Y2goe1xuICAgICAgSnVzdDogaVkgPT4gTWF5YmUuanVzdChJbW11dGFibGUuaXMoaVgsIGlZKSksXG4gICAgICBOb3RoaW5nOiAoKSA9PiBNYXliZS5ub3RoaW5nKCksXG4gICAgfSlcbiAgICBOb3RoaW5nOiAoKSA9PiBNYXliZS5ub3RoaW5nKCksXG4gIH0pOyAvLyBKdXN0KGZhbHNlKVxuICBgYGBcblxuICBJbiBzdW1tYXJ5OiBhbnl3aGVyZSB5b3UgaGF2ZSB0d28gYE1heWJlYCBpbnN0YW5jZXMgYW5kIG5lZWQgdG8gcGVyZm9ybSBhblxuICBvcGVyYXRpb24gdGhhdCB1c2VzIGJvdGggb2YgdGhlbSwgYGFwYCBpcyB5b3VyIGZyaWVuZC5cblxuICBUd28gdGhpbmdzIHRvIG5vdGUsIGJvdGggcmVnYXJkaW5nICpjdXJyeWluZyo6XG5cbiAgMS4gIEFsbCBmdW5jdGlvbnMgcGFzc2VkIHRvIGBhcGAgbXVzdCBiZSBjdXJyaWVkLiBUaGF0IGlzLCB0aGV5IG11c3QgYmUgb2YgdGhlXG4gICAgICBmb3JtIChmb3IgYWRkKSBgKGE6IG51bWJlcikgPT4gKGI6IG51bWJlcikgPT4gYSArIGJgLCAqbm90KiB0aGUgbW9yZSB1c3VhbFxuICAgICAgYChhOiBudW1iZXIsIGI6IG51bWJlcikgPT4gYSArIGJgIHlvdSBzZWUgaW4gSmF2YVNjcmlwdCBtb3JlIGdlbmVyYWxseS5cblxuICAgICAgRm9yIGNvbnZlbmllbmNlLCB5b3UgbWF5IHdhbnQgdG8gbG9vayBhdCBMb2Rhc2gncyBgXy5jdXJyeWAgb3IgUmFtZGEnc1xuICAgICAgYFIuY3VycnlgLCB3aGljaCBhbGxvdyB5b3UgdG8gY3JlYXRlIGN1cnJpZWQgdmVyc2lvbnMgb2YgZnVuY3Rpb25zXG4gICAgICB3aGVuZXZlciB5b3Ugd2FudDpcblxuICAgICAgYGBgXG4gICAgICBpbXBvcnQgTWF5YmUgZnJvbSAndHJ1ZS1teXRoL21heWJlJztcbiAgICAgIGltcG9ydCB7IGN1cnJ5IH0gZnJvbSAnbG9kYXNoJztcblxuICAgICAgY29uc3Qgbm9ybWFsQWRkID0gKGE6IG51bWJlciwgYjogbnVtYmVyKSA9PiBhICsgYjtcbiAgICAgIGNvbnN0IGN1cnJpZWRBZGQgPSBjdXJyeShub3JtYWxBZGQpOyAvLyAoYTogbnVtYmVyKSA9PiAoYjogbnVtYmVyKSA9PiBhICsgYjtcblxuICAgICAgTWF5YmUub2YoY3VycmllZEFkZCkuYXAoTWF5YmUub2YoMSkpLmFwKE1heWJlLm9mKDUpKTsgLy8gSnVzdCg2KVxuICAgICAgYGBgXG5cbiAgMi4gIFlvdSB3aWxsIG5lZWQgdG8gY2FsbCBgYXBgIGFzIG1hbnkgdGltZXMgYXMgdGhlcmUgYXJlIGFyZ3VtZW50cyB0byB0aGVcbiAgICAgIGZ1bmN0aW9uIHlvdSdyZSBkZWFsaW5nIHdpdGguIFNvIGluIHRoZSBjYXNlIG9mIGBhZGRgLCB3aGljaCBoYXMgdGhlXG4gICAgICBcImFyaXR5XCIgKGZ1bmN0aW9uIGFyZ3VtZW50IGNvdW50KSBvZiAyIChgYWAgYW5kIGBiYCksIHlvdSdsbCBuZWVkIHRvIGNhbGxcbiAgICAgIGBhcGAgdHdpY2U6IG9uY2UgZm9yIGBhYCwgYW5kIG9uY2UgZm9yIGBiYC4gVG8gc2VlIHdoeSwgbGV0J3MgbG9vayBhdCB3aGF0XG4gICAgICB0aGUgcmVzdWx0IGluIGVhY2ggcGhhc2UgaXM6XG5cbiAgICAgIGBgYHRzXG4gICAgICBjb25zdCBhZGQgPSAoYTogbnVtYmVyKSA9PiAoYjogbnVtYmVyKSA9PiBhICsgYjtcblxuICAgICAgY29uc3QgbWF5YmVBZGQgPSBNYXliZS5vZihhZGQpOyAvLyBKdXN0KChhOiBudW1iZXIpID0+IChiOiBudW1iZXIpID0+IGEgKyBiKVxuICAgICAgY29uc3QgbWF5YmVBZGQxID0gbWF5YmVBZGQuYXAoTWF5YmUub2YoMSkpOyAvLyBKdXN0KChiOiBudW1iZXIpID0+IDEgKyBiKVxuICAgICAgY29uc3QgZmluYWwgPSBtYXliZUFkZDEuYXAoTWF5YmUub2YoMykpOyAvLyBKdXN0KDQpXG4gICAgICBgYGBcblxuICAgICAgU28gZm9yIGB0b1N0cmluZ2AsIHdoaWNoIGp1c3QgdGFrZXMgYSBzaW5nbGUgYXJndW1lbnQsIHlvdSB3b3VsZCBvbmx5IG5lZWRcbiAgICAgIHRvIGNhbGwgYGFwYCBvbmNlLlxuXG4gICAgICBgYGB0c1xuICAgICAgY29uc3QgdG9TdHIgPSAodjogeyB0b1N0cmluZygpOiBzdHJpbmcgfSkgPT4gdi50b1N0cmluZygpO1xuICAgICAgTWF5YmUub2YodG9TdHIpLmFwKDEyKTsgLy8gSnVzdChcIjEyXCIpXG4gICAgICBgYGBcblxuICBPbmUgb3RoZXIgc2NlbmFyaW8gd2hpY2ggZG9lc24ndCBjb21lIHVwICpxdWl0ZSogYXMgb2Z0ZW4gYnV0IGlzIGNvbmNlaXZhYmxlXG4gIGlzIHdoZXJlIHlvdSBoYXZlIHNvbWV0aGluZyB0aGF0IG1heSBvciBtYXkgbm90IGFjdHVhbGx5IGNvbnN0cnVjdCBhIGZ1bmN0aW9uXG4gIGZvciBoYW5kbGluZyBhIHNwZWNpZmljIGBNYXliZWAgc2NlbmFyaW8uIEluIHRoYXQgY2FzZSwgeW91IGNhbiB3cmFwIHRoZVxuICBwb3NzaWJseS1wcmVzZW50IGluIGBhcGAgYW5kIHRoZW4gd3JhcCB0aGUgdmFsdWVzIHRvIGFwcGx5IHRvIHRoZSBmdW5jdGlvbiB0b1xuICBpbiBgTWF5YmVgIHRoZW1zZWx2ZXMuXG5cbiAgKipBc2lkZToqKiBgYXBgIGlzIG5vdCBuYW1lZCBgYXBwbHlgIGJlY2F1c2Ugb2YgdGhlIG92ZXJsYXAgd2l0aCBKYXZhU2NyaXB0J3NcbiAgZXhpc3RpbmcgW2BhcHBseWBdIGZ1bmN0aW9uIOKAkyBhbmQgYWx0aG91Z2ggc3RyaWN0bHkgc3BlYWtpbmcsIHRoZXJlIGlzbid0IGFueVxuICBkaXJlY3Qgb3ZlcmxhcCAoYE1heWJlLmFwcGx5YCBhbmQgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAgZG9uJ3QgaW50ZXJzZWN0XG4gIGF0IGFsbCkgaXQncyB1c2VmdWwgdG8gaGF2ZSBhIGRpZmZlcmVudCBuYW1lIHRvIGF2b2lkIGltcGx5aW5nIHRoYXQgdGhleSdyZVxuICB0aGUgc2FtZS5cblxuICBbYGFwcGx5YF06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2FwcGx5XG5cbiAgQHBhcmFtIG1heWJlRm4gbWF5YmUgYSBmdW5jdGlvbiBmcm9tIFQgdG8gVVxuICBAcGFyYW0gbWF5YmUgbWF5YmUgYSBUIHRvIGFwcGx5IHRvIGBmbmBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwPFQsIFU+KG1heWJlRm46IE1heWJlPCh0OiBUKSA9PiBVPiwgbWF5YmU6IE1heWJlPFQ+KTogTWF5YmU8VT47XG5leHBvcnQgZnVuY3Rpb24gYXA8VCwgVT4obWF5YmVGbjogTWF5YmU8KHQ6IFQpID0+IFU+KTogKG1heWJlOiBNYXliZTxUPikgPT4gTWF5YmU8VT47XG5leHBvcnQgZnVuY3Rpb24gYXA8VCwgVT4oXG4gIG1heWJlRm46IE1heWJlPCh2YWw6IFQpID0+IFU+LFxuICBtYXliZT86IE1heWJlPFQ+XG4pOiBNYXliZTxVPiB8ICgodmFsOiBNYXliZTxUPikgPT4gTWF5YmU8VT4pIHtcbiAgY29uc3Qgb3AgPSAobTogTWF5YmU8VD4pID0+XG4gICAgbS5tYXRjaCh7XG4gICAgICBKdXN0OiB2YWwgPT4gbWF5YmVGbi5tYXAoZm4gPT4gZm4odmFsKSksXG4gICAgICBOb3RoaW5nOiAoKSA9PiBNYXliZS5ub3RoaW5nPFU+KCksXG4gICAgfSk7XG5cbiAgcmV0dXJuIGN1cnJ5MShvcCwgbWF5YmUpO1xufVxuXG4vKipcbiAgRGV0ZXJtaW5lIHdoZXRoZXIgYW4gaXRlbSBpcyBhbiBpbnN0YW5jZSBvZiBgSnVzdGAgb3IgYE5vdGhpbmdgLlxuXG4gIEBwYXJhbSBpdGVtIFRoZSBpdGVtIHRvIGNoZWNrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJbnN0YW5jZTxUID0gYW55PihpdGVtOiBhbnkpOiBpdGVtIGlzIE1heWJlPFQ+IHtcbiAgcmV0dXJuIGl0ZW0gaW5zdGFuY2VvZiBKdXN0IHx8IGl0ZW0gaW5zdGFuY2VvZiBOb3RoaW5nO1xufVxuXG50eXBlIFByZWRpY2F0ZTxUPiA9IChlbGVtZW50OiBULCBpbmRleDogbnVtYmVyLCBhcnJheTogVFtdKSA9PiBib29sZWFuO1xuXG4vLyBOT1RFOiBkb2N1bWVudGF0aW9uIGlzIGxpZ2h0bHkgYWRhcHRlZCBmcm9tIHRoZSBNRE4gYW5kIFR5cGVTY3JpcHQgZG9jcyBmb3Jcbi8vIGBBcnJheS5wcm90b3R5cGUuZmluZGAuXG4vKipcbiAgU2FmZWx5IHNlYXJjaCBmb3IgYW4gZWxlbWVudCBpbiBhbiBhcnJheS5cbiAgXG4gIFRoaXMgZnVuY3Rpb24gYmVoYXZlcyBsaWtlIGBBcnJheS5wcm90b3R5cGUuZmluZGAsIGJ1dCByZXR1cm5zIGBNYXliZTxUPmBcbiAgaW5zdGVhZCBvZiBgVCB8IHVuZGVmaW5lZGAuXG4gIFxuICAjIyBFeGFtcGxlc1xuXG4gIFRoZSBiYXNpYyBmb3JtIGlzOlxuXG4gIGBgYHRzXG4gIGltcG9ydCBNYXliZSBmcm9tICd0cnVlLW15dGgvbWF5YmUnO1xuXG4gIGxldCBhcnJheSA9IFsxLCAyLCAzXTtcbiAgTWF5YmUuZmluZCh2ID0+IHYgPiAxLCBhcnJheSk7IC8vIEp1c3QoMilcbiAgTWF5YmUuZmluZCh2ID0+IHYgPCAxLCBhcnJheSk7IC8vIE5vdGhpbmdcbiAgYGBgXG5cbiAgVGhlIGZ1bmN0aW9uIGlzIGN1cnJpZWQgc28geW91IGNhbiB1c2UgaXQgaW4gYSBmdW5jdGlvbmFsIGNoYWluLiBGb3IgZXhhbXBsZVxuICAobGVhdmluZyBhc2lkZSBlcnJvciBoYW5kbGluZyBvbiBhIGJhZCByZXNwb25zZSBmb3Igc2ltcGxpY2l0eSksIHN1cHBvc2UgdGhlXG4gIHVybCBgaHR0cHM6Ly9hcnJheXMuZXhhbXBsZS5jb21gIHJldHVybmVkIGEgSlNPTiBwYXlsb2FkIHdpdGggdGhlIHR5cGVcbiAgYEFycmF5PHsgY291bnQ6IG51bWJlciwgbmFtZTogc3RyaW5nIH0+YCwgYW5kIHdlIHdhbnRlZCB0byBnZXQgdGhlIGZpcnN0XG4gIG9mIHRoZXNlIHdoZXJlIGBjb3VudGAgd2FzIGF0IGxlYXN0IDEwMC4gV2UgY291bGQgd3JpdGUgdGhpczpcblxuICBgYGB0c1xuICBpbXBvcnQgTWF5YmUgZnJvbSAndHJ1ZS1teXRoL21heWJlJztcblxuICB0eXBlIEl0ZW0gPSB7IGNvdW50OiBudW1iZXI7IG5hbWU6IHN0cmluZyB9O1xuICB0eXBlIFJlc3BvbnNlID0gQXJyYXk8SXRlbT47XG5cbiAgLy8gY3VycmllZCB2YXJpYW50IVxuICBjb25zdCBmaW5kQXRMZWFzdDEwMCA9IE1heWJlLmZpbmQoKHsgY291bnQgfTogSXRlbSkgPT4gY291bnQgPiAxMDApO1xuXG4gIGZldGNoKCdodHRwczovL2FycmF5cy5leGFtcGxlLmNvbScpXG4gICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpIGFzIFJlc3BvbnNlKVxuICAgIC50aGVuKGZpbmRBdExlYXN0MTAwKVxuICAgIC50aGVuKGZvdW5kID0+IHtcbiAgICAgIGlmIChmb3VuZC5pc0p1c3QoKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgVGhlIG1hdGNoaW5nIHZhbHVlIGlzICR7Zm91bmQudmFsdWUubmFtZX0hYCk7XG4gICAgICB9XG4gICAgfSk7XG4gIGBgYFxuICBcbiAgQHBhcmFtIHByZWRpY2F0ZSAgQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggdmFsdWUgaW4gdGhlIGFycmF5LCByZXR1cm5pbmdcbiAgICAgICAgICAgICAgICAgICAgYHRydWVgIHdoZW4gdGhlIGl0ZW0gaW4gdGhlIGFycmF5IG1hdGNoZXMgdGhlIGNvbmRpdGlvbi4gVGhlXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZSBmb3IgYHByZWRpY2F0ZWAgaXMgaWRlbnRpY2FsIHRvIHRoZSBzaWduYXR1cmUgZm9yXG4gICAgICAgICAgICAgICAgICAgIHRoZSBmaXJzdCBhcmd1bWVudCB0byBgQXJyYXkucHJvdG90eXBlLmZpbmRgLiBUaGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgaXMgY2FsbGVkIG9uY2UgZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgYXJyYXksIGluIGFzY2VuZGluZ1xuICAgICAgICAgICAgICAgICAgICBvcmRlciwgdW50aWwgaXQgZmluZHMgb25lIHdoZXJlIHByZWRpY2F0ZSByZXR1cm5zIHRydWUuIElmXG4gICAgICAgICAgICAgICAgICAgIHN1Y2ggYW4gZWxlbWVudCBpcyBmb3VuZCwgZmluZCBpbW1lZGlhdGVseSByZXR1cm5zIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCB2YWx1ZSB3cmFwcGVkIGluIGBKdXN0YC4gT3RoZXJ3aXNlLCBgTWF5YmUuZmluZGBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJucyBgTm90aGluZ2AuXG4gKiBAcGFyYW0gYXJyYXkgICAgIFRoZSBhcnJheSB0byBzZWFyY2ggdXNpbmcgdGhlIHByZWRpY2F0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmQ8VD4ocHJlZGljYXRlOiBQcmVkaWNhdGU8VD4sIGFycmF5OiBUW10pOiBNYXliZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiBmaW5kPFQ+KHByZWRpY2F0ZTogUHJlZGljYXRlPFQ+KTogKGFycmF5OiBUW10pID0+IE1heWJlPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmQ8VD4oXG4gIHByZWRpY2F0ZTogUHJlZGljYXRlPFQ+LFxuICBhcnJheT86IFRbXVxuKTogTWF5YmU8VD4gfCAoKGFycmF5OiBUW10pID0+IE1heWJlPFQ+KSB7XG4gIGNvbnN0IG9wID0gKGE6IFRbXSkgPT4gTWF5YmUub2YoYS5maW5kKHByZWRpY2F0ZSkpO1xuICByZXR1cm4gY3VycnkxKG9wLCBhcnJheSk7XG59XG5cbi8qKlxuICBTYWZlbHkgZ2V0IHRoZSBmaXJzdCBpdGVtIGZyb20gYSBsaXN0LCByZXR1cm5pbmcgYEp1c3RgIHRoZSBmaXJzdCBpdGVtIGlmIHRoZVxuICBhcnJheSBoYXMgYXQgbGVhc3Qgb25lIGl0ZW0gaW4gaXQsIG9yIGBOb3RoaW5nYCBpZiBpdCBpcyBlbXB0eS5cblxuICAjIyBFeGFtcGxlc1xuXG4gIGBgYHRzXG4gIGxldCBlbXB0eSA9IFtdO1xuICBNYXliZS5oZWFkKGVtcHR5KTsgLy8gPT4gTm90aGluZ1xuXG4gIGxldCBmdWxsID0gWzEsIDIsIDNdO1xuICBNYXliZS5oZWFkKGZ1bGwpOyAvLyA9PiBKdXN0KDEpXG4gIGBgYFxuXG4gIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgdG8gZ2V0IHRoZSBmaXJzdCBpdGVtIGZyb20uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZWFkPFQ+KGFycmF5OiBBcnJheTxUIHwgbnVsbCB8IHVuZGVmaW5lZD4pOiBNYXliZTxUPiB7XG4gIHJldHVybiBNYXliZS5vZihhcnJheVswXSk7XG59XG5cbi8qKiBBIGNvbnZlbmllbmNlIGFsaWFzIGZvciBgTWF5YmUuaGVhZGAuICovXG5leHBvcnQgY29uc3QgZmlyc3QgPSBoZWFkO1xuXG4vKipcbiAgU2FmZWx5IGdldCB0aGUgbGFzdCBpdGVtIGZyb20gYSBsaXN0LCByZXR1cm5pbmcgYEp1c3RgIHRoZSBsYXN0IGl0ZW0gaWYgdGhlXG4gIGFycmF5IGhhcyBhdCBsZWFzdCBvbmUgaXRlbSBpbiBpdCwgb3IgYE5vdGhpbmdgIGlmIGl0IGlzIGVtcHR5LlxuXG4gICMjIEV4YW1wbGVzXG5cbiAgYGBgdHNcbiAgbGV0IGVtcHR5ID0gW107XG4gIE1heWJlLmxhc3QoZW1wdHkpOyAvLyA9PiBOb3RoaW5nXG5cbiAgbGV0IGZ1bGwgPSBbMSwgMiwgM107XG4gIE1heWJlLmxhc3QoZnVsbCk7IC8vID0+IEp1c3QoMylcbiAgYGBgXG5cbiAgQHBhcmFtIGFycmF5IFRoZSBhcnJheSB0byBnZXQgdGhlIGZpcnN0IGl0ZW0gZnJvbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxhc3Q8VD4oYXJyYXk6IEFycmF5PFQgfCBudWxsIHwgdW5kZWZpbmVkPik6IE1heWJlPFQ+IHtcbiAgcmV0dXJuIE1heWJlLm9mKGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdKTtcbn1cblxuLyoqXG4gIENvbnZlcnQgdGhlIGFyZ3VtZW50cyB0byBhIHNpbmdsZSBgTWF5YmVgLiBVc2VmdWwgZm9yIGRlYWxpbmcgd2l0aCBhcnJheXMgb2ZcbiAgYE1heWJlYHMsIHZpYSB0aGUgc3ByZWFkIG9wZXJhdG9yLlxuXG4gICMjIEV4YW1wbGVzXG5cbiAgYGBgdHNcbiAgaW1wb3J0IE1heWJlIGZyb20gJ3RydWUtbXl0aC9tYXliZSc7XG5cbiAgbGV0IHZhbGlkID0gW01heWJlLmp1c3QoMiksIE1heWJlLmp1c3QoJ3RocmVlJyldO1xuICBNYXliZS5hbGwoLi4udmFsaWQpOyAvLyA9PiBKdXN0KFsyLCAndGhyZWUnXSk7XG5cbiAgbGV0IGludmFsaWQgPSBbTWF5YmUuanVzdCgyKSwgTWF5YmUubm90aGluZzxzdHJpbmc+KCldO1xuICBNYXliZS5hbGwoLi4uaW52YWxpZCk7IC8vID0+IE5vdGhpbmdcbiAgYGBgXG5cbiAgIyMgTm90ZSBvbiBTcHJlYWRcblxuICBUaGlzIHJlcXVpcmVzIHRoZSB1c2Ugb2YgdGhlIHNwcmVhZCBvcGVyYXRvciBiZWNhdXNlIChhdCBsZWFzdCBhcyBvZlxuICBUeXBlU2NyaXB0IDMuMCksIHRoZSB0eXBlIGluZmVyZW5jZSBmYWxscyBkb3duIHdoZW4gYXR0ZW1wdGluZyB0byBidWlsZCB0aGlzXG4gIHNhbWUgdHlwZSB3aXRoIGFuIGFycmF5IGRpcmVjdGx5LiBNb3Jlb3ZlciwgdGhpcyBzcHJlYWQtYmFzZWQgYXBwcm9hY2ggaGFuZGxlc1xuICBoZXRlcmVnZW5vdXMgYXJyYXlzOyBUUyAqYWxzbyogZmFpbHMgdG8gaW5mZXIgY29ycmVjdGx5IGZvciBhbnl0aGluZyBidXRcbiAgaG9tb2dlbmVvdXMgYXJyYXlzIHdoZW4gdXNpbmcgdGhhdCBhcHByb2FjaC5cblxuICBAcGFyYW0gbWF5YmVzIFRoZSBgTWF5YmVgcyB0byByZXNvbHZlIHRvIGEgc2luZ2xlIGBNYXliZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbGw8VCBleHRlbmRzIEFycmF5PE1heWJlPHVua25vd24+Pj4oLi4ubWF5YmVzOiBUKTogQWxsPFQ+IHtcbiAgbGV0IHJlc3VsdDogQWxsPFQ+ID0gTWF5YmUuanVzdChbXSBhcyBNYXliZTx1bmtub3duPltdKSBhcyBBbGw8VD47XG4gIG1heWJlcy5mb3JFYWNoKG1heWJlID0+IHtcbiAgICByZXN1bHQgPSByZXN1bHQuYW5kVGhlbihhY2N1bXVsYXRlZE1heWJlcyA9PlxuICAgICAgbWF5YmUubWFwKG0gPT4ge1xuICAgICAgICBhY2N1bXVsYXRlZE1heWJlcy5wdXNoKG0pO1xuICAgICAgICByZXR1cm4gYWNjdW11bGF0ZWRNYXliZXM7XG4gICAgICB9KVxuICAgICkgYXMgQWxsPFQ+O1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG50eXBlIEFsbDxUIGV4dGVuZHMgQXJyYXk8TWF5YmU8YW55Pj4+ID0gVCBleHRlbmRzIEFycmF5PE1heWJlPGluZmVyIFU+PiA/IE1heWJlPEFycmF5PFU+PiA6IG5ldmVyO1xuXG4vKipcbiAgR2l2ZW4gYSB0dXBsZSBvZiBgTWF5YmVgcywgcmV0dXJuIGEgYE1heWJlYCBvZiB0aGUgdHVwbGUgdmFsdWVzLlxuXG4gIEdpdmVuIGEgdHVwbGUgb2YgdHlwZSBgW01heWJlPEE+LCBNYXliZTxCPl1gLCB0aGUgcmVzdWx0aW5nIHR5cGUgaXNcbiAgYE1heWJlPFtBLCBCXT5gLiBXb3JrcyB3aXRoIHVwIHRvIGEgNS10dXBsZS4gKElmIHlvdSdyZSBkb2luZyBtb3JlIHRoYW4gYVxuICA1LXR1cGxlLCB3aGF0IGFyZSB5b3UgZG9pbmc/Pz8pXG5cbiAgIyMgRXhhbXBsZXNcblxuICBJZiBhbnkgb2YgdGhlIGl0ZW1zIGluIHRoZSB0dXBsZSBhcmUgYE5vdGhpbmdgLCB0aGUgd2hvbGUgcmVzdWx0IGlzIGBOb3RoaW5nYC5cbiAgSGVyZSwgZm9yIGV4YW1wbGUsIGByZXN1bHRgIGhhcyB0aGUgdHlwZSBgTWF5YmU8W3N0cmluZywgbnVtYmVyXT5gIGFuZCB3aWxsIGJlXG4gIGBOb3RoaW5nYDpcblxuICBgYGB0c1xuICBpbXBvcnQgTWF5YmUgZnJvbSAndHJ1ZS1teXRoL21heWJlJztcblxuICB0eXBlIFR1cGxlID0gW01heWJlPHN0cmluZz4sIE1heWJlPG51bWJlcj5dO1xuXG4gIGxldCBpbnZhbGlkOiBUdXBsZSA9IFtNYXliZS5qdXN0KCd3YXQnKSwgTWF5YmUubm90aGluZygpXTtcbiAgbGV0IHJlc3VsdCA9IE1heWJlLnR1cGxlKGludmFsaWQpOyAgLy8gPT4gTm90aGluZ1xuICBgYGBcblxuICBJZiBhbGwgb2YgdGhlIGl0ZW1zIGluIHRoZSB0dXBsZSBhcmUgYEp1c3RgLCB0aGUgcmVzdWx0IGlzIGBKdXN0YCB3cmFwcGluZyB0aGVcbiAgdHVwbGUgb2YgdGhlIHZhbHVlcyBvZiB0aGUgaXRlbXMuIEhlcmUsIGZvciBleGFtcGxlLCBgcmVzdWx0YCBhZ2FpbiBoYXMgdGhlXG4gIHR5cGUgYE1heWJlPFtzdHJpbmcsIG51bWJlcl0+YCBhbmQgd2lsbCBiZSBgSnVzdChbJ2hleScsIDEyXWA6XG5cbiAgYGBgdHNcbiAgaW1wb3J0IE1heWJlIGZyb20gJ3RydWUtbXl0aC9tYXliZSc7XG5cbiAgdHlwZSBUdXBsZSA9IFtNYXliZTxzdHJpbmc+LCBNYXliZTxudW1iZXI+XTtcblxuICBsZXQgdmFsaWQ6IFR1cGxlID0gW01heWJlLmp1c3QoJ2hleScpLCBNYXliZS5qdXN0KDEyKV07XG4gIGxldCByZXN1bHQgPSBNYXliZS50dXBsZSh2YWxpZCk7ICAvLyA9PiBKdXN0KFsnaGV5JywgMTJdKVxuICBgYGBcblxuICBAcGFyYW0gbWF5YmVzOiB0aGUgdHVwbGUgb2YgYE1heWJlYHMgdG8gY29udmVydCB0byBhIGBNYXliZWAgb2YgdHVwbGUgdmFsdWVzLlxuICovXG4vLyBAdHMtaWdub3JlIC0tIHRoaXMgZG9lc24ndCB0eXBlLWNoZWNrLCBidXQgaXQgaXMgY29ycmVjdCFcbmV4cG9ydCBmdW5jdGlvbiB0dXBsZTxUPihtYXliZXM6IFtNYXliZTxUPl0pOiBNYXliZTxbVF0+O1xuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPFQsIFU+KG1heWJlczogW01heWJlPFQ+LCBNYXliZTxVPl0pOiBNYXliZTxbVCwgVV0+O1xuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPFQsIFUsIFY+KG1heWJlczogW01heWJlPFQ+LCBNYXliZTxVPiwgTWF5YmU8Vj5dKTogTWF5YmU8W1QsIFUsIFZdPjtcbmV4cG9ydCBmdW5jdGlvbiB0dXBsZTxULCBVLCBWLCBXPihcbiAgbWF5YmVzOiBbTWF5YmU8VD4sIE1heWJlPFU+LCBNYXliZTxWPiwgTWF5YmU8Vz5dXG4pOiBNYXliZTxbVCwgVSwgViwgV10+O1xuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlPFQsIFUsIFYsIFcsIFg+KFxuICBtYXliZXM6IFtNYXliZTxUPiwgTWF5YmU8VT4sIE1heWJlPFY+LCBNYXliZTxXPiwgTWF5YmU8WD5dXG4pOiBNYXliZTxbVCwgVSwgViwgVywgWF0+IHtcbiAgLy8gQHRzLWlnbm9yZSAtLSB0aGlzIGRvZXNuJ3QgdHlwZS1jaGVjaywgYnV0IGl0IHdvcmtzIGNvcnJlY3RseS5cbiAgcmV0dXJuIGFsbCguLi5tYXliZXMpO1xufVxuXG4vKipcbiAgU2FmZWx5IGV4dHJhY3QgYSBrZXkgZnJvbSBhbiBvYmplY3QsIHJldHVybmluZyBgSnVzdGAgaWYgdGhlIGtleSBoYXMgYSB2YWx1ZVxuICBvbiB0aGUgb2JqZWN0IGFuZCBgTm90aGluZ2AgaWYgaXQgZG9lcyBub3QuXG5cbiAgVGhlIGNoZWNrIGlzIHR5cGUtc2FmZTogeW91IHdvbid0IGV2ZW4gYmUgYWJsZSB0byBjb21waWxlIGlmIHlvdSB0cnkgdG8gbG9va1xuICB1cCBhIHByb3BlcnR5IHRoYXQgVHlwZVNjcmlwdCAqa25vd3MqIGRvZXNuJ3QgZXhpc3Qgb24gdGhlIG9iamVjdC5cblxuICBgYGB0c1xuICB0eXBlIFBlcnNvbiA9IHsgbmFtZT86IHN0cmluZyB9O1xuXG4gIGNvbnN0IG1lOiBQZXJzb24gPSB7IG5hbWU6ICdDaHJpcycgfTtcbiAgY29uc29sZS5sb2coTWF5YmUucHJvcGVydHkoJ25hbWUnLCBtZSkpOyAvLyBKdXN0KCdDaHJpcycpXG5cbiAgY29uc3Qgbm9ib2R5OiBQZXJzb24gPSB7fTtcbiAgY29uc29sZS5sb2coTWF5YmUucHJvcGVydHkoJ25hbWUnLCBub2JvZHkpKTsgLy8gTm90aGluZ1xuICBgYGBcblxuICBIb3dldmVyLCBpdCBhbHNvIHdvcmtzIGNvcnJlY3RseSB3aXRoIGRpY3Rpb25hcnkgdHlwZXM6XG5cbiAgYGBgdHNcbiAgdHlwZSBEaWN0PFQ+ID0geyBba2V5OiBzdHJpbmddOiBUIH07XG5cbiAgY29uc3Qgc2NvcmU6IERpY3Q8bnVtYmVyPiA9IHtcbiAgICBwbGF5ZXIxOiAwLFxuICAgIHBsYXllcjI6IDFcbiAgfTtcblxuICBjb25zb2xlLmxvZyhNYXliZS5wcm9wZXJ0eSgncGxheWVyMScsIHNjb3JlKSk7IC8vIEp1c3QoMClcbiAgY29uc29sZS5sb2coTWF5YmUucHJvcGVydHkoJ3BsYXllcjInLCBzY29yZSkpOyAvLyBKdXN0KDEpXG4gIGNvbnNvbGUubG9nKE1heWJlLnByb3BlcnR5KCdwbGF5ZXIzJywgc2NvcmUpKTsgLy8gTm90aGluZ1xuICBgYGBcblxuICBUaGUgb3JkZXIgb2Yga2V5cyBpcyBzbyB0aGF0IGl0IGNhbiBiZSBwYXJ0aWFsbHkgYXBwbGllZDpcblxuICBgYGB0c1xuICB0eXBlIFBlcnNvbiA9IHsgbmFtZT86IHN0cmluZyB9O1xuICBcbiAgY29uc3QgbG9va3VwTmFtZSA9IE1heWJlLnByb3BlcnR5KCduYW1lJyk7XG4gIFxuICBjb25zdCBtZTogUGVyc29uID0geyBuYW1lOiAnQ2hyaXMnIH07XG4gIGNvbnNvbGUubG9nKGxvb2t1cE5hbWUobWUpKTsgLy8gSnVzdCgnQ2hyaXMnKVxuXG4gIGNvbnN0IG5vYm9keTogUGVyc29uID0ge307XG4gIGNvbnNvbGUubG9nKGxvb2t1cE5hbWUobm9ib2R5KSk7IC8vIE5vdGhpbmdcbiAgYGBgXG4gIFxuICBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gcHVsbCBvdXQgb2YgdGhlIG9iamVjdC5cbiAgQHBhcmFtIG9iaiBUaGUgb2JqZWN0IHRvIGxvb2sgdXAgdGhlIGtleSBmcm9tLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvcGVydHk8VCwgSyBleHRlbmRzIGtleW9mIFQ+KGtleTogSywgb2JqOiBUKTogTWF5YmU8UmVxdWlyZWQ8VD5bS10+O1xuZXhwb3J0IGZ1bmN0aW9uIHByb3BlcnR5PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPihrZXk6IEspOiAob2JqOiBUKSA9PiBNYXliZTxSZXF1aXJlZDxUPltLXT47XG5leHBvcnQgZnVuY3Rpb24gcHJvcGVydHk8VCwgSyBleHRlbmRzIGtleW9mIFQ+KFxuICBrZXk6IEssXG4gIG9iaj86IFRcbik6IE1heWJlPFJlcXVpcmVkPFQ+W0tdPiB8ICgob2JqOiBUKSA9PiBNYXliZTxSZXF1aXJlZDxUPltLXT4pIHtcbiAgY29uc3Qgb3AgPSAoYTogVCkgPT4gTWF5YmUub2YoYVtrZXldKTtcbiAgcmV0dXJuIGN1cnJ5MShvcCwgb2JqKTtcbn1cblxuLyoqXG4gIFNhZmVseSBleHRyYWN0IGEga2V5IGZyb20gYSBNYXliZSBvZiBhbiBvYmplY3QsIHJldHVybmluZyBgSnVzdGAgaWYgdGhlIGtleVxuICBoYXMgYSB2YWx1ZSBvbiB0aGUgb2JqZWN0IGFuZCBgTm90aGluZ2AgaWYgaXQgZG9lcyBub3QuIChMaWtlIGBNYXliZS5wcm9wZXJ0eWBcbiAgYnV0IG9wZXJhdGluZyBvbiBhIGBNYXliZTxUPmAgcmF0aGVyIHRoYW4gZGlyZWN0bHkgb24gYSBgVGAuKVxuXG4gIFRoZSBjaGVjayBpcyB0eXBlLXNhZmU6IHlvdSB3b24ndCBldmVuIGJlIGFibGUgdG8gY29tcGlsZSBpZiB5b3UgdHJ5IHRvIGxvb2tcbiAgdXAgYSBwcm9wZXJ0eSB0aGF0IFR5cGVTY3JpcHQgKmtub3dzKiBkb2Vzbid0IGV4aXN0IG9uIHRoZSBvYmplY3QuXG5cbiAgYGBgdHNcbiAgdHlwZSBQZXJzb24gPSB7IG5hbWU/OiBzdHJpbmcgfTtcblxuICBjb25zdCBtZTogTWF5YmU8UGVyc29uPiA9IE1heWJlLmp1c3QoeyBuYW1lOiAnQ2hyaXMnIH0pO1xuICBjb25zb2xlLmxvZyhNYXliZS5nZXQoJ25hbWUnLCBtZSkpOyAvLyBKdXN0KCdDaHJpcycpXG5cbiAgY29uc3Qgbm9ib2R5ID0gTWF5YmUubm90aGluZzxQZXJzb24+KCk7XG4gIGNvbnNvbGUubG9nKE1heWJlLmdldCgnbmFtZScsIG5vYm9keSkpOyAvLyBOb3RoaW5nXG4gIGBgYFxuXG4gIEhvd2V2ZXIsIGl0IGFsc28gd29ya3MgY29ycmVjdGx5IHdpdGggZGljdGlvbmFyeSB0eXBlczpcblxuICBgYGB0c1xuICB0eXBlIERpY3Q8VD4gPSB7IFtrZXk6IHN0cmluZ106IFQgfTtcblxuICBjb25zdCBzY29yZTogTWF5YmU8RGljdDxudW1iZXI+PiA9IE1heWJlLmp1c3Qoe1xuICAgIHBsYXllcjE6IDAsXG4gICAgcGxheWVyMjogMVxuICB9KTtcblxuICBjb25zb2xlLmxvZyhNYXliZS5nZXQoJ3BsYXllcjEnLCBzY29yZSkpOyAvLyBKdXN0KDApXG4gIGNvbnNvbGUubG9nKE1heWJlLmdldCgncGxheWVyMicsIHNjb3JlKSk7IC8vIEp1c3QoMSlcbiAgY29uc29sZS5sb2coTWF5YmUuZ2V0KCdwbGF5ZXIzJywgc2NvcmUpKTsgLy8gTm90aGluZ1xuICBgYGBcblxuICBUaGUgb3JkZXIgb2Yga2V5cyBpcyBzbyB0aGF0IGl0IGNhbiBiZSBwYXJ0aWFsbHkgYXBwbGllZDpcblxuICBgYGB0c1xuICB0eXBlIFBlcnNvbiA9IHsgbmFtZT86IHN0cmluZyB9O1xuICBcbiAgY29uc3QgbG9va3VwTmFtZSA9IE1heWJlLmdldCgnbmFtZScpO1xuICBcbiAgY29uc3QgbWU6IFBlcnNvbiA9IHsgbmFtZTogJ0NocmlzJyB9O1xuICBjb25zb2xlLmxvZyhsb29rdXBOYW1lKG1lKSk7IC8vIEp1c3QoJ0NocmlzJylcblxuICBjb25zdCBub2JvZHk6IFBlcnNvbiA9IHt9O1xuICBjb25zb2xlLmxvZyhsb29rdXBOYW1lKG5vYm9keSkpOyAvLyBOb3RoaW5nXG4gIGBgYFxuICBcbiAgQHBhcmFtIGtleSBUaGUga2V5IHRvIHB1bGwgb3V0IG9mIHRoZSBvYmplY3QuXG4gIEBwYXJhbSBvYmogVGhlIG9iamVjdCB0byBsb29rIHVwIHRoZSBrZXkgZnJvbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4oa2V5OiBLLCBtYXliZU9iajogTWF5YmU8VD4pOiBNYXliZTxSZXF1aXJlZDxUPltLXT47XG5leHBvcnQgZnVuY3Rpb24gZ2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPihrZXk6IEspOiAobWF5YmVPYmo6IE1heWJlPFQ+KSA9PiBNYXliZTxSZXF1aXJlZDxUPltLXT47XG5leHBvcnQgZnVuY3Rpb24gZ2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPihcbiAga2V5OiBLLFxuICBtYXliZU9iaj86IE1heWJlPFQ+XG4pOiBNYXliZTxSZXF1aXJlZDxUPltLXT4gfCAoKG1heWJlT2JqOiBNYXliZTxUPikgPT4gTWF5YmU8UmVxdWlyZWQ8VD5bS10+KSB7XG4gIHJldHVybiBjdXJyeTEoTWF5YmUuYW5kVGhlbihwcm9wZXJ0eTxULCBLPihrZXkpKSwgbWF5YmVPYmopO1xufVxuXG4vKiogQSB2YWx1ZSB3aGljaCBtYXkgKGBKdXN0PFQ+YCkgb3IgbWF5IG5vdCAoYE5vdGhpbmdgKSBiZSBwcmVzZW50LiAqL1xuZXhwb3J0IHR5cGUgTWF5YmU8VD4gPSBKdXN0PFQ+IHwgTm90aGluZzxUPjtcbmV4cG9ydCBjb25zdCBNYXliZSA9IHtcbiAgVmFyaWFudCxcbiAgSnVzdCxcbiAgTm90aGluZyxcbiAgYWxsLFxuICBpc0p1c3QsXG4gIGlzTm90aGluZyxcbiAganVzdCxcbiAgbm90aGluZyxcbiAgb2YsXG4gIGZpbmQsXG4gIGZpcnN0LFxuICBmcm9tTnVsbGFibGUsXG4gIGhlYWQsXG4gIGxhc3QsXG4gIG1hcCxcbiAgbWFwT3IsXG4gIG1hcE9yRWxzZSxcbiAgYW5kLFxuICBhbmRUaGVuLFxuICBjaGFpbixcbiAgZmxhdE1hcCxcbiAgb3IsXG4gIG9yRWxzZSxcbiAgdW5zYWZlbHlVbndyYXAsXG4gIHVuc2FmZWx5R2V0LFxuICB1bnNhZmVHZXQsXG4gIHVud3JhcE9yLFxuICBnZXRPcixcbiAgdW53cmFwT3JFbHNlLFxuICBnZXRPckVsc2UsXG4gIHRvT2tPckVycixcbiAgdG9Pa09yRWxzZUVycixcbiAgZnJvbVJlc3VsdCxcbiAgdG9TdHJpbmcsXG4gIHR1cGxlLFxuICBtYXRjaCxcbiAgY2F0YSxcbiAgZXF1YWxzLFxuICBhcCxcbiAgaXNJbnN0YW5jZSxcbiAgcHJvcGVydHksXG4gIGdldCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE1heWJlO1xuIl19